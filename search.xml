<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二分法查找元素]]></title>
    <url>%2F2019%2F04%2F30%2F%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * 二分查找的前提: 数组元素必须有序. * 如果数组元素无序,那么请使用基本查找 */public class BinarySearchDemo &#123; public static void main(String[] args) &#123; // 定义一个数组 int[] arr = &#123;13, 24, 57, 69, 80&#125; ; // 调用方法 int index = binarySearch(arr , 80) ; // 输出 System.out.println(&quot;index: &quot; + index); &#125; /** * 二分查找 */ private static int binarySearch2(int[] arr, int value) &#123; // 定义两个int类型的变量 int minIndex = 0 ; int maxIndex = arr.length - 1 ; while(minIndex &lt;= maxIndex)&#123; // 计算出中间索引 int midIndex = (minIndex + maxIndex) &gt;&gt;&gt; 1 ; // 比较 if(arr[midIndex] == value)&#123; return midIndex ; &#125;else if(arr[midIndex] &gt; value)&#123; maxIndex = midIndex - 1 ; &#125;else if(arr[midIndex] &lt; value)&#123; minIndex = midIndex + 1 ; &#125; &#125; return -1; &#125; /** * 二分查找 */ private static int binarySearch(int[] arr, int value) &#123; // 定义两个int类型的变量 int minIndex = 0 ; int maxIndex = arr.length - 1 ; // 计算出中间索引 int midIndex = (minIndex + maxIndex) / 2 ; while(minIndex &lt;= maxIndex)&#123; // 比较 if(arr[midIndex] == value)&#123; return midIndex ; &#125;else if(arr[midIndex] &gt; value)&#123; maxIndex = midIndex - 1 ; &#125;else if(arr[midIndex] &lt; value)&#123; minIndex = midIndex + 1 ; &#125; midIndex = (minIndex + maxIndex) / 2 ; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[希尔排序]]></title>
    <url>%2F2019%2F04%2F29%2F%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[希尔排序算法原理希尔排序又称缩小增量排序。 基本思想：先将原表按增量ht分组，每个子文件按照直接插入法排序。同样，用下一个增量ht/2 将文件再分为子文件，再直接插入法排序。直到ht=1时整个文件拍好序。 关键：选择合适的增量 希尔排序算法：可以通过三重循环来实现 希尔排序图示 希尔排序特点主要特点： ​ 每一趟以不同的增量进行插入排序。当d较大时，被移动的记录是跳跃式进行的。到最后一趟排序时（d=1）， 许多记录已经有序，不需要多少移动，所以提高了排序的速度。 希尔排序的时间复杂度分析与选择的增量有关系。它是不稳定的排序方法。 增量的合理选择最普通的选择就是使用数组长度的一半 这种增量从效率来说，不是非常好 增量的选择knuth序列 h = 1 h = 3*h+1 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125import java.util.Arrays;public class ShellSortDemo &#123; public static void main(String[] args) &#123; //希尔排序,是对插入排序的优化 int[] arr = &#123;9, 4, 5, 6, 1, 0, 3, 2, 10, 20, 11, 24, 32, 13&#125;; //insertSort3(arr); shellSort(arr); System.out.println(Arrays.toString(arr)); &#125; private static void shellSort(int[] arr) &#123; //定义序列的间隔为4 /* int h=4; for (int i =h; i &lt; arr.length; i++) &#123; for (int j = i; j &gt;h-1;j-=h) &#123; if (arr[j] &lt; arr[j - h]) &#123; swapValue(arr, j, j - h); &#125; &#125; &#125; h = 2; //缩小间隔为2 for (int i = h; i &lt; arr.length; i++) &#123; for (int j = i; j &gt; h - 1; j -= h) &#123; if (arr[j] &lt; arr[j - h]) &#123; swapValue(arr, j, j - h); &#125; &#125; &#125; h = 1; //缩小间隔为3 for (int i = h; i &lt; arr.length; i++) &#123; for (int j = i; j &gt; h - 1; j -= h) &#123; if (arr[j] &lt; arr[j - h]) &#123; swapValue(arr, j, j - h); &#125; &#125; &#125; */ //把上面的代码改进一下 /* for (int h = 4; h &gt; 0; h /= 2) &#123; for (int i = h; i &lt; arr.length; i++) &#123; for (int j = i; j &gt; h - 1; j -= h) &#123; if (arr[j] &lt; arr[j - h]) &#123; swapValue(arr, j, j - h); &#125; &#125; &#125; &#125; */ //再来优化,我们这个间隔,可以取数组长度的一半 /* for (int h =arr.length/2; h &gt; 0; h /= 2) &#123; for (int i = h; i &lt; arr.length; i++) &#123; for (int j = i; j &gt; h - 1; j -= h) &#123; if (arr[j] &lt; arr[j - h]) &#123; swapValue(arr, j, j - h); &#125; &#125; &#125; &#125;*/ //间隔取成数组长度的一半,也不是很好,我们可以使用 //h=1 // h = 3 * h + 1 例如: 1,4,13,40,121,364 //算出第一次的最最大间隔 int jiange = 1; while (jiange &lt;= arr.length / 3) &#123; jiange = 3 * jiange + 1; &#125; for (int h = jiange; h &gt; 0; h = (h - 1) / 3) &#123; for (int i = h; i &lt; arr.length; i++) &#123; for (int j = i; j &gt; h - 1; j -= h) &#123; if (arr[j] &lt; arr[j - h]) &#123; swapValue(arr, j, j - h); &#125; &#125; &#125; &#125; &#125; private static void insertSort3(int[] arr) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = i; j &gt; 0; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; swapValue(arr, j, j - 1); &#125; &#125; &#125; &#125; private static void insertSort2(int[] arr) &#123; //直接插入排序,可以看作是间隔为1的希尔排序 int h = 1; for (int i = h; i &lt; arr.length; i++) &#123; for (int j = i; j &gt; h - 1; j -= h) &#123; if (arr[j] &lt; arr[j - h]) &#123; swapValue(arr, j, j - h); &#125; &#125; &#125; &#125; private static void swapValue(int[] arr, int i, int j) &#123; int t = arr[i]; arr[i] = arr[j]; arr[j] = t; &#125; private static void insertSort(int[] arr) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; int j = i; while (j &gt; 0 &amp;&amp; arr[j - 1] &gt; arr[j]) &#123; swapValue(arr, j, j - 1); j--; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2F2019%2F04%2F29%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[归并排序算法思想归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。 分而治之 合并相邻有序子序列 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.util.Arrays;public class ArrayDemo &#123; public static void main(String[] args) &#123; //归并排序： //治理：将两个有序子序列，合并成一个有序序列 // int[] arr=&#123;1,3,5,7,9,2,4,6,8,10&#125;; // //mergeSort(arr,0,4,arr.length-1); int[] arr = &#123;1, 4,6,0,-1,4,9,20,35,98, 9, 2, 4, 6, 8, 10,-4,1000,800&#125;; chaiFen(arr,0,arr.length-1); System.out.println(Arrays.toString(arr)); &#125; private static void chaiFen(int[] arr, int startIndext, int endIndex) &#123; //计算中间索引 int centerIndex=(startIndext+endIndex)/2; if(startIndext&lt;endIndex)&#123; //递归拆左边 chaiFen(arr, startIndext, centerIndex); //递归拆右边 chaiFen(arr, centerIndex + 1, endIndex); mergeSort(arr, startIndext, centerIndex, endIndex); &#125; &#125; /** * * @param arr 要归并排序的数组 * @param startIndtx 起始索引 * @param centerIndex 中间索引 * @param endIndex 结束索引 */ private static void mergeSort(int[] arr, int startIndtx, int centerIndex, int endIndex) &#123; //定义一个临时数组 int[] tempArray=new int[endIndex-startIndtx+1]; //定义第一数组的起始索引 int i=startIndtx; //定义第二个数组的起始索引 int j=centerIndex+1; //定义临时数组的索引 int index=0; //两个数组元素，进行对比归并 while (i&lt;=centerIndex&amp;&amp;j&lt;=endIndex)&#123; if(arr[i]&lt;=arr[j])&#123; //把小的数放到临时数组中 tempArray[index]=arr[i]; i++; //递增一下索引 &#125;else&#123; tempArray[index] = arr[j]; j++; //递增一下索引 &#125; index++; //临时数组的索引也要递增 &#125; //处理剩余元素 while (i&lt;=centerIndex)&#123; tempArray[index]=arr[i]; i++; index++; &#125; while (j&lt;=endIndex)&#123; tempArray[index] = arr[j]; j++; index++; &#125; //经过上面的操作后，临时数组中的元素就排序好了 // System.out.println(Arrays.toString(tempArray)); //把临时数组中的元素放到原数组中 for (int k = 0; k &lt; tempArray.length; k++) &#123; arr[startIndtx+k]=tempArray[k]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2019%2F04%2F29%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class BubbleSortDemo &#123; public static void main(String[] args) &#123; // 定义一个数组 int[] arr = &#123;24, 69, 80, 57, 13&#125; ; // 遍历方法 System.out.print(&quot;排序前: &quot;); print(arr) ; // 排序 bubbleSort2(arr); // 排序后的输出 System.out.print(&quot;排序后: &quot;); print(arr) ; &#125; /** * 优化后的冒泡排序 */ private static void bubbleSort2(int[] arr) &#123; for(int x = 0 ; x &lt; arr.length - 1 ; x++)&#123; /* * arr.length - 1: 目的是为了防止数组角标越界 * arr.length - 1 - x : -x目的是为了提高效率 */ for(int y = 0 ; y &lt; arr.length - 1 - x ; y++)&#123; if(arr[y] &gt; arr[y + 1])&#123; int temp = arr[y] ; arr[y] = arr[y+1]; arr[y+1] = temp ; &#125; &#125; &#125; &#125; /** * 冒泡排序 */ private static void bubbleSort(int[] arr) &#123; // 第一次排序 // arr.length - 1 目的: 防止数组角标越界 for(int x = 0 ; x &lt; arr.length - 1 - 0; x++)&#123; if(arr[x] &gt; arr[ x + 1 ])&#123; int temp = arr[x] ; arr[x] = arr[ x + 1]; arr[ x + 1 ] = temp ; &#125; &#125; // 第二次排序 for(int x = 0 ; x &lt; arr.length - 1 - 1; x++)&#123; if(arr[x] &gt; arr[ x + 1 ])&#123; int temp = arr[x] ; arr[x] = arr[ x + 1]; arr[ x + 1 ] = temp ; &#125; &#125; // 第三次排序 for(int x = 0 ; x &lt; arr.length - 1 - 2; x++)&#123; if(arr[x] &gt; arr[ x + 1 ])&#123; int temp = arr[x] ; arr[x] = arr[ x + 1]; arr[ x + 1 ] = temp ; &#125; &#125; // 第四次排序 for(int x = 0 ; x &lt; arr.length - 1 - 3; x++)&#123; if(arr[x] &gt; arr[ x + 1 ])&#123; int temp = arr[x] ; arr[x] = arr[ x + 1]; arr[ x + 1 ] = temp ; &#125; &#125; &#125; /** * 遍历数组的方法 */ public static void print(int[] arr)&#123; System.out.print(&quot;[&quot;); for(int x = 0 ; x &lt; arr.length ; x++)&#123; if(x == arr.length - 1)&#123; System.out.println(arr[x] + &quot;]&quot;); &#125;else &#123; System.out.print(arr[x] + &quot;, &quot;); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2019%2F04%2F29%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[算法思想：1.分治法：比大小，再分区 2.从数组中取出一个数，作为基准数。 分区：将比这个数大或等于的数全放到他的右边，小于他的数 全放到他的左边。 3.再对左右区间重复第二步，直到各区间只有一个数。 实现思路1.挖坑填数 2.将基准数挖出形成第一个坑。 3.由后向前找比他小的数，找到后挖出此数填到前一个坑中。 由前向后找比他大或等于的数，找到后也挖出此数填到前一个坑中。 4.再重复执行2，3两步骤。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class QuickSort &#123; //start 默认是0 //end 是数组长度-1 public void quickSort(int[] arr, int start, int end) &#123; if (start &lt; end) &#123; //获取分区索引 int index = getIndex(arr, start, end); //对左右两个分区 再进行同样的步骤 ，即是递归调用 quickSort(arr, start, index - 1);//左半部分 quickSort(arr, index + 1, end);//右半部分 &#125; &#125; private int getIndex(int[] arr, int start, int end) &#123; int i = start; int j = end; //定义基准数 int x = arr[i]; //循环 while (i &lt; j) &#123; //从右往左比较 while (i &lt; j &amp;&amp; arr[j] &gt;= x) &#123; j--; &#125; //从右往左找到比基准数小的数了后，填坑 if (i &lt; j) &#123; //把这个数填到上一个坑位 arr[i] = arr[j]; //让 i++; i++; &#125; //从左往右找 while (i &lt; j &amp;&amp; arr[i] &lt; x) &#123; i++; &#125; // 找比基准数大的数，找到后填坑 if (i &lt; j) &#123; arr[j] = arr[i]; j--; &#125; &#125; //当上面的循环结束后把基准数填到最后一个坑位，也就一基准数为界，分成了左右两部分 arr[i] = x; //把基准数填进去 return i; //返回基准数所在位置的索引 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[直接插入排序]]></title>
    <url>%2F2019%2F04%2F29%2F%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.Arrays;public class MyTest &#123; public static void main(String[] args) &#123; //直接插入排序 //算法思想 /*直接插入排序, 是一种最简单的排序方法.他的基本操作是将一个记录插入到一个长度为m 的有序表中, 使之仍保持有序, 从而得到一个新的长度为m + 1 的有序列表.假设有一组元素 &#123; k1, k2...,kn &#125;, 排序开始就认为k1是一个有序序列, 让k2插入上述表长为1的有序序列, 使之成为一个表长为2的有序序列, 然后让k3插入上述表长为2的有序序列, 使之成为一个表长为3的有序序列, 以此类推, 最后让kn插入表长为n - 1 的有序序列, 得到一个表长为n的有序序列. 例如: 49, 38, 65, 97, 76, 13, 27 原始数据 [49], 38, 65, 97, 76, 13, 27 从1索引开始插入 [38, 49], ,65, 97, 76, 13, 27 [38, 49, 65]97, 76, 13, 27 [38, 49, 65, 97]76, 13, 27 [38, 49, 65, 76, 97]13, 27 [13, 27, 38, 49, 65, 76, 97],27 [13, 27, 38, 49, 65, 76, 97]*/ //代码实现 int[] arr=&#123;10,-1,1,1,3,5,6,9,0,100,3,-9,1000&#125;; //外层循环定义轮次 //[10] for (int i =1; i &lt; arr.length; i++) &#123; int j=i; //往之前的有序列表中插入元素，插入完之后，使之仍保持有序 while (j&gt;0&amp;&amp;arr[j]&lt;arr[j-1])&#123;//当前元素arr[i] 跟我前面一个元素去比 arr[i-1] int t=arr[j]; arr[j]=arr[j-1]; arr[j-1]=t; j--; &#125; &#125; System.out.println(Arrays.toString(arr)); //插入排序，还有很多优化的变种，比如希尔排序，就是对插入排序的优化排法 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序]]></title>
    <url>%2F2019%2F04%2F29%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class SelectSortDemo &#123; public static void main(String[] args) &#123; // 定义一个数组 int[] arr = &#123;24, 69, 80, 57, 13&#125; ; // 遍历方法 System.out.print(&quot;排序前: &quot;); BubbleSortDemo.print(arr) ; // 选择排序 selectSort2(arr) ; // 排序后的输出 System.out.print(&quot;排序后: &quot;); BubbleSortDemo.print(arr) ; &#125; /** * 选择排序 */ private static void selectSort2(int[] arr) &#123; for(int index = 0 ; index &lt; arr.length - 1 ; index++)&#123; for(int x = 1 + index ; x &lt; arr.length ; x++)&#123; if(arr[x] &lt; arr[index])&#123; int temp = arr[x] ; arr[x] = arr[index] ; arr[index] = temp ; &#125; &#125; &#125; &#125; /** * 选择排序的推导过程 */ private static void selectSort(int[] arr) &#123; // 第一次排序 // 定义一个int类型的变量 int index = 0 ; // 循环 for(int x = 1 + index ; x &lt; arr.length ; x++)&#123; if(arr[x] &lt; arr[index])&#123; int temp = arr[x] ; arr[x] = arr[index] ; arr[index] = temp ; &#125; &#125; // 第二次排序 index = 1 ; // 循环 for(int x = 1 + index ; x &lt; arr.length ; x++)&#123; if(arr[x] &lt; arr[index])&#123; int temp = arr[x] ; arr[x] = arr[index] ; arr[index] = temp ; &#125; &#125; // 第三次排序 index = 2 ; // 循环 for(int x = 1 + index ; x &lt; arr.length ; x++)&#123; if(arr[x] &lt; arr[index])&#123; int temp = arr[x] ; arr[x] = arr[index] ; arr[index] = temp ; &#125; &#125; // 第四次排序 index = 3 ; // 循环 for(int x = 1 + index ; x &lt; arr.length ; x++)&#123; if(arr[x] &lt; arr[index])&#123; int temp = arr[x] ; arr[x] = arr[index] ; arr[index] = temp ; &#125; &#125; &#125; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象【五】(抽象类、接口)]]></title>
    <url>%2F2019%2F04%2F18%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%90%E4%BA%94%E3%80%91(%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3)%2F</url>
    <content type="text"><![CDATA[抽象类抽象类的概述回想前面我们的猫狗案例，提取出了一个动物类。并且我们在前面也创建过了动物对象，其实这是不对的。为什么呢?因为，我说动物，你知道我说的是什么动物吗?只有看到了具体的动物，你才知道，这是什么动物。所以说，动物本身并不是一个具体的事物，而是一个抽象的事物。只有真正的猫，狗才是具体的动物。同理，我们也可以推想，不同的动物吃的东西应该是不一样的，所以，我们不应该在动物类中给出成员方法的具体体现，而是应该给出一个声明即可。 在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类。 抽象类的特点 抽象类和抽象方法必须用abstract关键字修饰 格式:抽象类： 1abstract class 类名 &#123;&#125;； 抽象方法： 1public abstract void eat(); 注意： 抽象类不一定有抽象方法，有抽象方法的类一定是抽象类 问：抽象类中可以有构造方法,抽象类不能进行实例化,那么要构造方法有什么作用呢? 答：用于子类访问父类数据时的初始化 问：抽象类不能直接实例化那么，抽象类如何实例化呢? 答：按照多态的方式，由具体的子类实例化。其实这也是多态的一种，抽象类多态。 抽象类的子类 要么是抽象类要么重写抽象类中的所有抽象方法 代码示例：（以下代码是自定义类） 123456789101112131415161718192021222324252627282930313233//一旦一个类中，有了抽象方法，此类必须为抽象类public abstract class Animal &#123; public Animal() &#123; System.out.println(&quot;父类的构造方法执行了&quot;); &#125; //abstract 抽象的，可以修饰类，修饰方法 public abstract void eat(); //抽象方法，此方法没有方法实现 public abstract void sleep(); //抽象类中既可以有抽象方法，也可以非抽象方法 public void show()&#123; System.out.println(&quot;这是父类的一个非抽象方法&quot;); &#125;&#125;class Cat extends Animal&#123; @Override public void eat() &#123; //对父类中的抽象方法进行重写，子类如果不是抽象类，必须对父类中的所有抽象方法进行重写 System.out.println(&quot;猫爱吃鱼&quot;); &#125; @Override public void sleep() &#123; System.out.println(&quot;猫白天睡觉&quot;); &#125;&#125; 一旦一个类中，有了抽象方法，此类必须为抽象类 对父类中的抽象方法进行重写，子类如果不是抽象类，必须对父类中的所有抽象方法进行重写 以下代码是测试类： 1234567891011public class MyTest &#123; public static void main(String[] args) &#123; //new Animal(); //抽象类不能直接创建对象 //我们可以采用多态间接的去实例化抽象类 Animal an=new Cat(); an.eat(); an.sleep(); an.show(); &#125;&#125; 在测试类中的主方法中的第一行代码执行时，用到了多态，那么最终运行结果为 1234父类的构造方法执行了猫爱吃鱼猫白天睡觉这是父类的一个非抽象方法 抽象类的成员特点及注意事项成员特点 成员变量：既可以是变量，也可以是常量。 构造方法：有，用于子类访问父类数据的初始化。 成员方法：既可以是抽象的，也可以是非抽象的。 抽象类的成员方法特性： 抽象方法： 强制要求子类重写的事情。非抽象方法： 子类继承的事情，提高代码复用性。 注意事项 抽象类，就是被abstract所修饰的类，父类将所有子类的共性功能向上抽取后，他并不知道，每个子类对这个共性功能的具体实现，所以没有必要在父类中，给出共性功能的具体实现，而是给出声明即可，所谓给出功能的声明，就是将此功能抽象出来，然后强制子类必须重写。 抽象类注意的事项：一旦一个类中，有了抽象方法，那么此类必须为抽象类 一个抽象类中可以没有抽象方法 抽象类中既可以有抽象方法，也可以有非抽象方法，抽象方法，强制子类重写；非抽象方法，可以让子类继承下去用 抽象类不能直接实例化，可以采用多态的方式，间接实例化 抽象类的子类，要么重写父类中所有的抽象方法，要么自己也是一个抽象类。 抽象类中有构造方法，用来子类初始化父类要用 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class MyTest &#123; public static void main(String[] args) &#123; Person p = new Student(); p.name = &quot;赵某某&quot;; p.age = 20; System.out.println(p.name + &quot;====&quot; + p.age); p.sleep(); p.playGame(); p.eat(); ((Student) p).watchTV(); System.out.println(&quot;------------------------&quot;); p = new Teacher(); p.name = &quot;沈某某&quot;; p.age = 21; System.out.println(p.name + &quot;===&quot; + p.age); p.eat(); p.playGame(); &#125;&#125;abstract class Person &#123; public String name; public int age; public abstract void eat(); public abstract void sleep(); public void playGame()&#123; System.out.println(&quot;玩游戏&quot;); &#125;&#125;class Student extends Person&#123; @Override public void eat() &#123; System.out.println(&quot;学生爱吃烤串&quot;); &#125; @Override public void sleep() &#123; System.out.println(&quot;学生通宵不寐&quot;); &#125; public void watchTV()&#123; System.out.println(&quot;学生看电视&quot;); &#125;&#125;class Teacher extends Person &#123; @Override public void eat() &#123; System.out.println(&quot;老师爱吃米饭&quot;); &#125; @Override public void sleep() &#123; System.out.println(&quot;老师经常失眠&quot;); &#125;&#125; 上述代码中使用到了向下转型，代码最终运行结果为 123456789赵某某====20学生通宵不寐玩游戏学生爱吃烤串学生看电视-------------沈某某===21老师爱吃米饭玩游戏 抽象类中的面试题 面试题1：一个类如果没有抽象方法，可不可以定义为抽象类?如果可以，有什么意义?答案: 可以 . 不能创建对象.因为抽象类不能实例化 面试题2：abstract不能和哪些关键字共存?private 冲突final 冲突 static 不能共存 无意义 接口接口的概述为了体现父类功能的扩展性，Java中就提供了接口来定义这些额外的拓展功能，并不给出具体实现，将来哪些子类需要使用到这些额外功能，只需要把这部分额外功能实现即可 接口特点 接口用关键字interface表示 格式: 1interface 接口名 &#123;&#125; 类实现接口用implements表示 格式: 1class 类名 implements 接口名 &#123;&#125; 接口不能实例化 12那么，接口如何实例化呢? 按照多态的方式来实例化。 接口的子类 可以是抽象类。但是意义不大。可以是具体类。要重写接口中的所有抽象方法。(推荐方案) 代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class MyTest &#123; public static void main(String[] args) &#123; Cat cat = new Cat(); Animal an = cat; an.eat(); // CalcInterface 是猫的一个父接口，所以猫类也可以看成是父接口的一个子类 CalcInterface calcInterface = cat; //接口不能直接实例化，但是可以使用多态类实例化 calcInterface.calc(); //多态 CalcInterface c = new Dog(); c.calc(); //接口不能new 对象 &#125;&#125;abstract class Animal &#123; public abstract void eat();&#125;interface CalcInterface &#123; //用来定义额外功能 public abstract void calc(); //接口中的方法只能是抽象类，即只需要声明，不需要具体实现，&#125;class Cat extends Animal implements CalcInterface&#123; @Override public void eat() &#123; //重写抽象类中的抽象方法 System.out.println(&quot;猫吃鱼&quot;); &#125; public void catcheMouse()&#123; 子类猫类的特有方法 System.out.println(&quot;猫抓老鼠&quot;); &#125; @Override public void calc() &#123; //因为接口中的方法只能是抽象方法，所以实现接口时必须对抽象方法进行实现 System.out.println(&quot;猫经过不断的努力学习，会做算术了&quot;); &#125;&#125;class Dog extends Animal implements CalcInterface&#123; @Override public void eat() &#123; System.out.println(&quot;狗吃骨头&quot;); &#125; public void lookDoor()&#123; System.out.println(&quot;狗看门&quot;); &#125; @Override public void calc() &#123; System.out.println(&quot;狗经过自己的学习，也学会了做算术&quot;); &#125;&#125; 上述代码执行结果为： 123猫吃鱼猫经过不断的努力学习，会做算术了狗经过自己的学习，也学会了做算术 接口的成员特点 成员变量；只能是常量，并且是静态的；默认修饰符：public static final；建议：自己手动给出。 构造方法：接口没有构造方法。 成员方法：只能是抽象方法；默认修饰符：public abstract；建议：自己手动给出。 代码示例： 1234567891011121314151617181920212223public class MyTest &#123; public static void main(String[] args) &#123; //接口中成员变量的特点 //接口中的成员变量全是静态的公共常量 //接口中没有构造方法的 //接口中没有非抽象方法，全是抽象方法 int a = A.A; System.out.println(a); int num = A.num; &#125;&#125;interface A&#123; //接口中成员变量前面有默认的修饰符 public static final int num=100; public static final int A=1000; //方法前面存在默认修饰符 public abstract public abstract void hehe(); void test();&#125; 类与类,类与接口,接口与接口的关系 类与类：继承关系,只能单继承,可以多层继承。 类与接口：实现关系,可以单实现,也可以多实现。并且还可以在继承一个类的同时实现多个接口。 接口与接口：继承关系,可以单继承,也可以多继承。 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class MyTest &#123; public static void main(String[] args) &#123; //类跟类之间的关系 // 类跟类是继承关系，只能是单继承，支持多层继承 // 类跟接口是实现关系 既可以实现一个接口，也可以实现多个接口,实现接口，必须重写接口中所有的抽象方法 // 接口跟接口的关系，继承关系，而且可以多继承 &#125;&#125;class Fu&#123;&#125;interface A&#123; void a();&#125;interface C&#123; void c();&#125;class B extends Fu implements A,C&#123; 类与接口可以多实现，也可以单实现 @Override public void a() &#123; &#125; @Override public void c() &#123; &#125;&#125;interface E&#123; void e();&#125;interface F&#123; void f(); void ff();&#125;interface G extends E,F&#123; 接口可以多继承 void g(); void gg();&#125;class V implements G&#123; @Override public void e() &#123; //以下都是对接口中的抽象方法进行重写 &#125; @Override public void f() &#123; &#125; @Override public void ff() &#123; &#125; @Override public void g() &#123; &#125; @Override public void gg() &#123; &#125;&#125; 抽象类和接口的区别成员区别： 抽象类： 成员变量：可以变量，也可以常量 构造方法：有 成员方法：可以抽象，也可以非抽象 接口： 成员变量：只可以常量 成员方法：只可以抽象 关系区别：​ 1.类与类：继承，单继承 ​ 2.类与接口：实现，单实现，多实现 ​ 3.接口与接口：继承，单继承，多继承 设计理念区别： 抽象类 被继承体现的是：”is a”的关系。 抽象类中定义的是该继承体系的共性功能。 接口 被实现体现的是：”like a”的关系。 接口中定义的是该继承体系的扩展功能。 注意：JDK1.8之后在接口中提供了用default修饰的方法，可以给出功能的具体实现，子类可以继承下去用，相当于间接实现了多继承 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class MyTest2 &#123; //JDK1.8之后，接口中可以定义默认方法 public static void main(String[] args) &#123; C c= new C(); A a=c; a.test(); a.test2(); a.test3(); B b=c; b.test22(); b.test333(); &#125;&#125;interface A&#123; void hehe(); public default void test()&#123; System.out.println(&quot;JDK1.8之后接口中，可以定义默认方法，可以有方法的具体实现&quot;); &#125; public default void test2() &#123; System.out.println(&quot;JDK1.8之后接口中，可以定义默认方法，可以有方法的具体实现&quot;); &#125; public default void test3() &#123; System.out.println(&quot;JDK1.8之后接口中，可以定义默认方法，可以有方法的具体实现&quot;); &#125;&#125;interface B &#123; void hehe(); public default void show() &#123; System.out.println(&quot;JDK1.8之后接口中，可以定义默认方法，可以有方法的具体实现？？？&quot;); &#125; public default void test22() &#123; System.out.println(&quot;JDK1.8之后接口中，可以定义默认方法，可以有方法的具体实现？？？&quot;); &#125; public default void test333() &#123; System.out.println(&quot;JDK1.8之后接口中，可以定义默认方法，可以有方法的具体实现？？？&quot;); &#125;&#125;class C implements A,B&#123; @Override public void hehe() &#123; &#125; @Override public void test22() &#123; System.out.println(&quot;JDK1.8之后接口中，可以定义默认方法，可以有方法的具体实现？？？，但是被重写了&quot;); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象【四】（final关键字、多态）]]></title>
    <url>%2F2019%2F04%2F17%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%90%E5%9B%9B%E3%80%91%EF%BC%88final%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E5%A4%9A%E6%80%81%EF%BC%89%2F</url>
    <content type="text"><![CDATA[final关键字 为什么会有final： ​ 由于继承中有一个方法重写的现象,而有时候我们不想让子类去重写父类的方法.这对这种情况java就给我们提供了一个关键字: final final概述： final关键字是最终的意思，可以修饰类，变量，成员方法 final关键字修饰类,方法以及变量的特点final修饰特点： 修饰类: 被修饰类不能被继承 修饰方法: 被修饰的方法不能被重写 修饰变量: 被修饰的变量不能被重新赋值,因为这个量其实是一个常量 代码示例： ​ final修饰成员变量： 12345678910public class MyTest &#123; public static final int A=10; //公共的静态常量 public static void main(String[] args) &#123; //final 最终的，可以修饰类，变量，可以修饰成员方法 final int NUM=100; //自定义常量 常量的命名字母全部大写 System.out.println(A); System.out.println(MyTest.A); System.out.println(NUM); &#125;&#125; 上述代码输出结果为： 1231010100 final修饰类：1234567891011121314151617181920public class MyTest&#123; public static void main(String[] args) &#123; //final 修饰类，此类不能被继承 B b = new B(); b.show1(); &#125;&#125;final class A&#123; public void show1()&#123; System.out.println(&quot;这是父类的成员方法&quot;); &#125;&#125;class B extends A&#123; public void show()&#123; System.out.println(&quot;这是子类的成员方法&quot;); &#125;&#125; 上述代码对类进行了final修饰，运行上述代码，会报错。 B类无法成功继承A类 final修饰成员方法：123456789101112131415161718192021222324public class MyTest &#123; public static void main(String[] args) &#123; //final 修饰方法，此方法不能被重写,子类可以原封不动的继承下去用，就是不能重写 new Zi().test(); &#125;&#125;class Fu&#123; public void show()&#123; System.out.println(&quot;这是父类的show方法&quot;); &#125; public final void test()&#123; System.out.println(&quot;这是父类的final&quot;); &#125;&#125;class Zi extends Fu&#123; @Override public void test() &#123; super.show(); &#125;&#125; 通过上述代码可以看出，通过final关键字修饰了成员方法，执行上述代码会报错，test()无法覆盖。 可知，被final修饰过的成员方法不能被子类重写。 final关键字修饰局部变量 基本类型，是值不能被改变 引用类型，是地址值不能被改变 多态的概述及其代码体现概述某一个事物，在不同时刻表现出来的不同状态。 举例： 12Cat c=new Cat();Animal a=new Cat(); 猫可以是猫的类型。猫 m = new 猫();同时猫也是动物的一种，也可以把猫称为动物。动物 d = new 猫(); 多态前提 要有继承关系。 要有方法重写。 其实没有也是可以的，但是如果没有这个就没有意义。 要有父类引用指向子类对象。父 f = new 子(); 代码示例： 12345678910111213141516171819202122232425262728293031323334public class MyTest &#123; public static void main(String[] args) &#123; Animal an=new Cat(); an.sleep(); an.eat(); an.show(); &#125;&#125;class Animal&#123; public void eat()&#123; System.out.println(&quot;吃饭&quot;); &#125; public void sleep() &#123; System.out.println(&quot;睡觉&quot;); &#125; public void show() &#123; System.out.println(&quot;父类中的show方法&quot;); &#125;&#125;class Cat extends Animal&#123; @Override public void eat() &#123; System.out.println(&quot;猫爱吃鱼&quot;); &#125; @Override public void sleep() &#123; System.out.println(&quot;猫爱白天睡觉&quot;); &#125;&#125; 上述代码就是对多态的举例，运行结果为： 123猫爱白天睡觉猫爱吃鱼父类中的show方法 多态中的成员访问特点多态中的成员访问特点 成员变量，编译看左边，运行看左边。 构造方法，创建子类对象的时候，会访问父类的构造方法，对父类的数据进行初始化。 成员方法，编译看左边，运行看右边。 静态方法，编译看左边，运行看左边(静态和类相关，算不上重写，所以，访问还是左边的)。 多态的好处多态的好处 提高了代码的维护性(继承保证) 提高了代码的扩展性(由多态保证) 多态的弊端通过多态的弊端引出问题： 不能使用子类特有的功能 解决方法： 把父类的引用强制转换为子类的引用。(向下转型) 向上转型和向下转型1.向上转型（upcasting）​ 子—-&gt;父 自动类型提升 2.向下转型（downcasting）​ 父—-&gt;子 强制类型转换 注意：无论是向上转型还是向下转型，两个类之间必须要有继承关系 代码示例： 父类： 动物类 12345public class Animal &#123; public void eat()&#123; System.out.println(&quot;动物在吃！&quot;); &#125;&#125; 子类1：猫类 12345678public class Cat extends Animal&#123; public void eat()&#123; System.out.println(&quot;猫吃鱼！&quot;); &#125; public void move()&#123; System.out.println(&quot;猫走猫步&quot;); &#125;&#125; 子类2：狗类 12345public class Dog extends Animal &#123; public void eat()&#123; System.out.println(&quot;狗啃骨头&quot;); &#125;&#125; 测试类1：没转型，正常调用 123456789101112public class Test &#123; public static void main(String[] args) &#123; Animal a1 = new Animal(); a1.eat(); Cat c1 = new Cat(); c1.eat(); Dog d1 = new Dog(); d1.eat(); &#125;&#125; 测试类2： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Test2 &#123; public static void main(String[] args) &#123; //向上转型又被称作：自动类型转换 //向上转型，子类转为父类 //父类型的引用指向子类型对象 //程序分两个阶段：编译阶段，运行阶段 //程序编译阶段只知道a1是一个Animal类 //程序运行的时候堆中的实际对象是Cat类型 Animal a1 = new Cat(); //程序在编译阶段a1被看做Animal类型 //所以程序在编一阶段a1引用绑定的是Animal类中的eat方法（静态绑定） a1.eat(); //猫吃鱼！ =========================================================== //向下转型，强制类型转换 Animal a2 = new Cat(); //要执行猫类的特有方法,怎么做？ Cat c1 = (Cat) a2; c1.move(); =========================================================== //抛出异常 //做强制类型转换是有风险的 Animal a3 = new Dog(); //向上转型，底层是Dog类 Cat c2 = (Cat) a3; //所以就不能强转成Cat类，因为之间没继承 //报错：ClassCastException //为了避免ClassCastException，引入了instanceof /* * 用法： 1.instanceof作为运算符返回的结果是boolean类型 2.(引用 instanceof 类型)-----&gt;true/false 例如：(a instanceof Cat) 如果是true，则a指向堆中的对象是Cat类型 ============================================================ Animal a3 = new Dog(); if(a3 instanceof Cat)&#123; Cat c2 =(Cat) a3; &#125; &#125;&#125; 静态绑定和动态绑定静态绑定：编译阶段a1引用绑定的是Animal类中的eat()方法。 动态绑定：但是运行阶段，堆中的对象实际上是Cat类型，而Cat已经重写了eat方法，所以程序在运行阶段对象的绑定的方法时Cat中的eat方法 instance可以判断类型 用法： 1.instanceof作为运算符返回的结果是boolean类型 2.(引用 instanceof 类型)-----&gt;true/false 例如：(a instanceof Cat) 如果是true，则a指向堆中的对象是Cat类型]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象【三】(代码块、继承、构造方法、方法重写)]]></title>
    <url>%2F2019%2F04%2F16%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%90%E4%B8%89%E3%80%91(%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E3%80%81%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99)%2F</url>
    <content type="text"><![CDATA[代码块 代码块概述 在Java中，使用{}括起来的代码被称为代码块。 代码块分类根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块(多线程讲解)。 常见代码块的应用： 1.局部代码块，在方法中出现；限定变量生命周期，及早释放，提高内存利用率 2.构造代码块，在类中方法外出现；在创建对象时执行，优先于构造方法执行，每创建一个对象都会执行 3.静态代码块，在类中方法外出现，加了static修饰，用于给类进行初始化，在加载的时候就执行，并且只执行一次。静态代码块里面只能访问静态变量 看程序写结果，语句后面的数字为执行顺序 123456789101112131415161718192021222324252627class Student &#123; static &#123; System.out.println(&quot;Student 静态代码块&quot;); //3 &#125; &#123; System.out.println(&quot;Student 构造代码块&quot;); //4 6 &#125; public Student() &#123; System.out.println(&quot;Student 构造方法&quot;); //5 7 &#125;&#125;class StudentDemo &#123; static &#123; System.out.println(&quot;StudentDemo的静态代码块&quot;);//1 &#125; public static void main(String[] args) &#123; System.out.println(&quot;我是main方法&quot;);//2 Student s1 = new Student(); Student s2 = new Student(); &#125;&#125; 继承 继承概述多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。 继承格式 通过extends关键字可以实现类与类的继承 class 子类名 extends 父类名 {} 单独的这个类称为父类，基类或者超类；这多个类可以称为子类或者派生类。 继承的好处和弊端​ 案例： 父类Person 123456789101112public class Person &#123; String name; int age; public void eat() &#123; System.out.println(&quot;吃饭&quot;); &#125; public void sleep() &#123; System.out.println(&quot;睡觉&quot;); &#125;&#125; 子类Student 123456public class Student extends Person&#123; public void talkLove()&#123; System.out.println(&quot;谈恋爱&quot;); &#125;&#125; 子类Teacher 1234567public class Teacher extends Person&#123; public void teache()&#123; System.out.println(&quot;教书&quot;); &#125;&#125; 从上述代码可以看出: Student和Teacher类继承了Person类的成员变量和成员方法，因为Teacher和Student作为人都会具有年龄和姓名两个属性，而且具有吃饭和睡觉的功能. 因为我们将这些子类所具有的相同功能都抽取到一个类中作为父类，所以Teacher和Student类不需要再写这些代码，只需要从父类那里继承就行，并且继承后可以在类中加入自己独特的功能代码，比如Teacher会教书，Student会谈恋爱。 继承完成后我们就可以利用Studnet和Teacher来创建各自的对象 测试类MyTest 1234567891011121314151617181920public class MyTest &#123; public static void main(String[] args) &#123; Student student = new Student(); student.name=&quot;张三&quot;; //调用了继承了父类的成员变量 student.age=19; System.out.println(student.name+&quot;===&quot;+student.age); student.sleep(); //调用了继承了父类的成员方法 student.eat(); student.talkLove(); //调用自己特有的方法 System.out.println(&quot;-----------------&quot;); Teacher teacher = new Teacher(); teacher.name=&quot;沈某某&quot;; teacher.age=10; System.out.println(teacher.name+&quot;===&quot;+teacher.age); teacher.sleep(); teacher.eat(); teacher.teache(); &#125;&#125; 继承的好处： 提高了代码的复用性 提高了代码的维护性（比如要想修改吃饭为吃米饭便可直接在父类中进行修改，而不用在两个子类中分别修改，提升了代码的维护性） 让类与类之间产生了关系，是多态的前提 继承的弊端：类的耦合性增强了。（可能改变了父类中的一些成员，导致它的子类中的东西也会改变，这也是耦合的缺点） 开发的原则：高内聚，低耦合。 耦合：类与类的关系 内聚：就是自己完成某件事情的能力 类的继承特点Java中类的继承特点： Java 只支持单继承，不支持多继承，有些语言是支持多继承，格式：extends 类1,类2,… Java支持多层继承(继承体系) Object是所有类的顶层父类，所有类都是直接，或间接继承自他 继承的注意事项 继承的注意事项： 子类只能继承父类所有非私有的成员(成员方法和成员变量) 子类不能继承父类的构造方法，但是可以通过super(待会儿讲)关键字去访问父类构造方法。 不要为了部分功能而去继承 什么时候使用继承： 如果有两个类A,B。只有他们符合A是B的一种，或者B是A的一种，就可以考虑使用继承。 继承中成员变量的关系 在使用继承时可能会存在下面两种情况： 1.子类中的成员变量和父类中的成员变量名称不一样 2.子类中的成员变量和父类中的成员变量名称一样 上述问题如何解决？这就涉及到之前讲过的变量查找顺序遵循的就近原则，是对之前的就近原则的拓展 在子类中访问一个变量的查找顺序(就近原则)： ​ 1.在子类的方法的局部范围找,有就使用 ​ 2.在子类的成员范围找,有就使用 ​ 3.在父类的成员范围找,有就使用 ​ 4.如果还找不到,就报错 代码示例：执行下面的测试类（子类中的成员方法形参、成员变量以及父类的成员变量名一样）后，如果我想输出 1231200100 程序中的成员方法应该如何定义 12345678910111213141516171819202122232425public class MyTest &#123; public static void main(String[] args) &#123; B b = new B(); int num=1; b.show(num); //变量的访问原则：遵循就近原则，先在局部找这个变量，找到就使用，如果局部没找到，去本类的成员位置找，找到就使用 //如果本类的成员位置没找到，去父类的成员位置找，找到就使用。 &#125;&#125;class A&#123; int num=100;&#125;class B extends A&#123; int num=200; public void show(int num)&#123; //就近访问原则 System.out.println(num); System.out.println(this.num); //System.out.println(new A().num); //涉及到匿名变量 System.out.println(super.num); //引入super关键字 &#125;&#125; this和super的区别和应用 this和super的区别：this 代表的是本类对象的引用，谁调用成员方法this就代表谁super代表的是父类存储空间的标识(可以理解成父类的引用,可以操作父类的成员) this和super的使用： 调用成员变量：1.this.成员变量 调用本类的成员变量 2.super.成员变量 调用父类的成员变量 调用构造方法：1.this(...) 调用本类的构造方法 2.super(...) 调用父类的构造方法 调用成员方法：1.this.成员方法 调用本类的成员方法2.super.成员方法 调用父类的成员方法 代码演示 1234567891011121314151617181920212223242526272829303132333435363738public class MyTest &#123; public static void main(String[] args) &#123; B b = new B(); //this() 访问本类的空参构造 b.show(1); // super() 访问父类的空参构造 b.hehe(); System.out.println(&quot;------------&quot;); b.test(); &#125;&#125;class A &#123; int a = 200; public void hehe() &#123; System.out.println(&quot;这是父类的一个方法&quot;); &#125;&#125;class B extends A &#123; int a = 100; public void show(int a) &#123; System.out.println(a); System.out.println(this.a); System.out.println(super.a); &#125; public void test2() &#123; System.out.println(&quot;这是子类test2方法&quot;); &#125; public void test() &#123; this.test2(); this.hehe();//本类对象调用父类的方法 super.hehe();//使用父类的空间标识去调用父类的方法 &#125;&#125; 根据上述讲解可知该代码演示最终的输出结果为 123456781100200这是父类的一个方法------------这是子类test2方法这是父类的一个方法这是父类的一个方法 继承中构造方法的关系子类中所有的构造方法默认都会访问父类中空参数的构造方法（来实现对父类的初始化） 原因：因为子类会继承父类中的数据，可能还会使用父类的数据，所以，子类初始化之前，一定要先完成父类数据的初始化。 其实：每一个构造方法的第一条语句默认都是：super()，只要在写构造方法时系统就会默认在第一条语句之前写上这条语句，但是不会显示，所以我们可以写也可以不写，不会影响对父类构造的初始化，注意Object没有父类。 代码示例： 1234567891011121314151617181920212223242526272829public class MyTest &#123; public static void main(String[] args) &#123; Son son = new Son(10); System.out.println(son.b); &#125;&#125;class Father&#123; int num=1000; public Father() &#123; super(); System.out.println(&quot;这是父类的空参构造&quot;); &#125;&#125;class Son extends Father&#123; int b=1; public Son() &#123; super(); System.out.println(&quot;这是子类的空参&quot;); &#125; public Son(int b) &#123; super(); this.b = b; System.out.println(&quot;子类有参构造执行了&quot;); &#125;&#125; 按照上述讲解可知上述代码最终输出结果如下： 123这是父类的空参构造子类有参构造执行了10 继承中构造方法的案例演示及注意事项 父类没有无参构造方法,子类怎么办? 在父类中添加一个无参的构造方法 子类通过super去显示调用父类其他的带参的构造方法 子类通过this去调用本类的其他构造方法，本类其他构造也必须首先访问了父类构造 注意事项：super(…)或者this(…)必须出现在第一条语句上，要在执行构造方法中的业务逻辑之前完成对父类构造方法的调用或者对本类其他构造方法的调用 代码示例： 12345678910111213141516171819202122232425262728293031323334public class MyTest &#123; public static void main(String[] args) &#123; ////假如我父类里面没有提供空参构造怎么办？ ////1.那子类可以去调父类有参构造 ////2.先用this(参数)本类的有参构造，然后你调用的那个构造又去调用父类的有参构造 //System.out.println(zi.num); Zi zi = new Zi(); &#125;&#125;class Fu&#123; int num=10; public Fu(int num) &#123; super(); this.num = num; System.out.println(&quot;父类的有参构造执行了&quot;); &#125;&#125;class Zi extends Fu&#123; int num=100; public Zi() &#123; super(10); // this(10000); System.out.println(&quot;子类的空参构造执行了&quot;); &#125; public Zi(int num) &#123; super(num); System.out.println(&quot;子类的有参构造执行了&quot;); &#125;&#125; 根据上述知识点讲解可知上述代码最终输出结果为： 12父类的有参构造执行了子类的空参构造执行了 继承中的面试题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758A:案例演示 看程序写结果1 class Fu&#123; public int num = 10; public Fu()&#123; System.out.println(&quot;fu&quot;); &#125; &#125; class Zi extends Fu&#123; public int num = 20; public Zi()&#123; System.out.println(&quot;zi&quot;); &#125; public void show()&#123; int num = 30; System.out.println(num);//30 System.out.println(this.num);//20 System.out.println(super.num);//10 &#125; &#125; class Test &#123; public static void main(String[] args) &#123; Zi z = new Zi(); z.show(); &#125; &#125;B:案例演示 看程序写结果2 class Fu &#123; static &#123; System.out.println(&quot;静态代码块Fu&quot;); //1 &#125; &#123; System.out.println(&quot;构造代码块Fu&quot;); //3 &#125; public Fu() &#123; System.out.println(&quot;构造方法Fu&quot;); //4 &#125; &#125; class Zi extends Fu &#123; static &#123; System.out.println(&quot;静态代码块Zi&quot;); //2 &#125; &#123; System.out.println(&quot;构造代码块Zi&quot;); //5 &#125; public Zi() &#123; System.out.println(&quot;构造方法Zi&quot;); //6 &#125; &#125; Zi z = new Zi(); 请执行结果。 A案例的输出结果为： 12345fuzi302010 B案例的输出结果为： 123456静态代码块Fu静态代码块Zi构造代码块Fu构造方法Fu构造代码块Zi构造方法Zi 继承中成员方法关系在使用继承时可能会出现下面两种情况： 当子类的方法名和父类的方法名不一样的时候 当子类的方法名和父类的方法名一样的时候 通过子类调用方法的查找顺序: 先查找子类中有没有该方法,如果有就使用 再看父类中有没有该方法,有就使用 如果没有就报错 1234567891011121314151617181920212223242526public class MyTest &#123; public static void main(String[] args) &#123; Zi zi = new Zi(); zi.show(); zi.test(); &#125;&#125;class Fu &#123; int num2=100; public void show()&#123; System.out.println(&quot;我是父类的show方法&quot;); &#125;&#125;class Zi extends Fu&#123; int num=200; public void test()&#123; System.out.println(&quot;我是子类的test方法&quot;); &#125; public void show() &#123; System.out.println(&quot;我是子类的show方法&quot;); &#125;&#125; 方法重写 什么是方法重写： 子类中出现了和父类中一模一样的方法声明(方法名,参数列表,返回值类型)，也被称为方法覆盖，方法复写。 方法重写的应用： 如果说子类对父类的方法实现不满意，那么子类就可以覆盖他，或者说，子类想要对父类的方法的实现功能进行扩展，也可以使用方法重写的这种机制 方法重写的注意事项 方法重写注意事项： 1.父类中私有方法不能被重写，因为父类私有方法子类根本就无法继承2.子类重写父类方法时，访问权限不能更低，最好就一致3.父类静态方法，子类也必须通过静态方法进行重写 其实这个算不上方法重写，但是现象确实如此 4.子类重写父类方法的时候，最好声明一模一样。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象【二】(this关键字、构造方法、static关键字、静态变量和成员变量的区别、Math类的随机数功能)]]></title>
    <url>%2F2019%2F04%2F14%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%90%E4%BA%8C%E3%80%91(this%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81Math%E7%B1%BB%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%8A%9F%E8%83%BD)%2F</url>
    <content type="text"><![CDATA[this关键字当我们的局部变量和成员变量相同的时候,如果我们不使用this关键字,那么会导致一个问题:就是局部变量隐藏了成员变量的问题。 this关键字代表当前类的引用，简单地说就是代表当前类的一个对象，谁调用这个方法，这个方法的内部的this就代表谁。 12345678910111213141516171819202122232425262728293031public class TestThis &#123; public static void main(String[] args) &#123; A a = new A(); System.out.println(a); int num=10; //定义在栈内存中 a.show(num,a); System.out.println(num); //10 &#125; &#125; class A&#123; int num=100; //定义在堆内存中 public void show(int num, A a)&#123; System.out.println(this); //本类引用 System.out.println(num); //10 System.out.println(a.num); //100 System.out.println(this.num); //100 System.out.println(a==this); &#125;&#125;输出：org.westos.homework0406.A@1540e19dorg.westos.homework0406.A@1540e19d10100100true10 构造方法 作用 创建对象时为对象中的成员进行初始化 特点 方法名与类名相同么有具体的返回值类型方法声明不写返回值类型，void也不用 注意事项 如果没有自定义构造方法，系统会自动提供一个空参构造；若给出了有参构造，系统将不再提供空参构造，如果还需要空参构造，必须手动给出 给成员变量赋值的两种方式a:setXxx()方法 b:构造方法 案例： 1234567891011121314151617181920212223242526272829303132333435public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void sleep() &#123; System.out.println(&quot;睡觉&quot;); &#125; public void eat() &#123; System.out.println(&quot;吃饭&quot;); &#125;&#125; static关键字​ static 静态的 可以修饰成员变量，和成员方法​ 被static所修饰的成员变量，是一个共享变量，被类的所有对象所共享​ 被静态所修饰的成员，是随时类的加载而加载（随着 .class文件进内存，静态的东西就会加载） ​ 优先于对象而存在 案例： 12345678910111213141516171819202122232425262728public class Person &#123; public String name; public static String country = &quot;中国&quot;;&#125;public class MyTest &#123; public static void main(String[] args) &#123; //想让中国，让这个三个对象共享 Person person = new Person(); person.name=&quot;张三&quot;; person.country=&quot;美国&quot;; System.out.println(&quot;---------------&quot;); Person person2 = new Person(); person2.name = &quot;李四&quot;; person2.country = &quot;新加坡&quot;; System.out.println(&quot;---------------&quot;); Person person3 = new Person(); person3.name = &quot;王五&quot;; person3.country = &quot;英国&quot;; System.out.println(person.name+&quot;----&quot;+person.country); //张三---英国 System.out.println(person2.name + &quot;----&quot; + person2.country); //李四---英国 System.out.println(person3.name + &quot;----&quot; + person3.country); //王五---英国 &#125;&#125; static关键字的特点 随着类的加载而加载可以通过类名调用优先于对象存在被类的所有对象共享 注意事项： 静态方法中不能使用this关键字，this表示本类的引用，即一个对象，而静态是虽类的加载而加载的，静态比对象先存在 静态方法只能访问静态成员变量和静态成员方法（静态只能访问静态） 静态变量和成员变量的区别 在内存中位置不同 静态变量存储在方法区的静态区成员变量存储在堆内存 所属不同 静态变量属于类（类变量）成员变量属于对象（实例变量/对象变量） 生命周期不同 静态变量随类的加载而加载，随类的消失而消失成员变量随对象的创建而存在，随对象的消失而消失 调用方式不同 静态变量既可以通过类名调用，也可以通过对象调用 成员变量只能通过对象调用 Math类的随机数功能 Math类包含用于执行基本数学运算的方法，由于Math类在java.lang包下，所以不需要导包。Math类没有构造方法，因为它的成员全部是静态的。 获取随机数的方法 public static double random():返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。若要获取一个1-100之间的随机数，可int number = (int)(Math.random()*100)+1; 案例：猜数字小游戏(数据在1-100之间) 12345678910111213141516171819202122232425import java.util.Scanner;public class RandomGame &#123; public static void main(String[] args) &#123; System.out.println(&quot;请输入一个数1~100&quot;); Scanner scanner = new Scanner(System.in); int answer = (int) (Math.random()*100+1); int index = 1; while (index&lt;=10)&#123; int num = scanner.nextInt(); if(num&gt;answer)&#123; System.out.println(&quot;猜大了&quot;); System.out.println(&quot;你还剩&quot;+(610-index)+&quot;次机会&quot;); index++; &#125;else if(num&lt;answer)&#123; System.out.println(&quot;猜小了&quot;); System.out.println(&quot;你还剩&quot;+(10-index)+&quot;次机会&quot;); index++; &#125;else &#123; System.out.println(&quot;恭喜你，猜对了&quot;); break; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象【一】（类、成员变量、局部变量、匿名对象、封装、private关键字）]]></title>
    <url>%2F2019%2F04%2F14%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%90%E4%B8%80%E3%80%91%EF%BC%88%E7%B1%BB%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%EF%BC%89%2F</url>
    <content type="text"><![CDATA[面向对象概述 面向过程思想概述一步一步去实现，而具体的每一步都需要我们去实现和操作。这些步骤相互调用和协作，完成我们的需求。在上面的每一个具体步骤中我们都是参与者，并且需要面对具体的每一个步骤和过程，这就是面向过程最直接的体现。那么什么是面向过程开发呢? 面向过程开发，其实就是面向着具体的每一个步骤和过程，把每一个步骤和过程完成，然后由这些功能方法相互调用，完成需求。代表语言：C语言 面向对象思想概述当需求单一，或者简单时，我们一步一步去操作没问题，并且效率也挺高。可随着需求的更改，功能的增多，发现需要面对每一个步骤很麻烦了。这时就开始思索，能不能把这些步骤和功能在进行封装，封装时根据不同的功能，进行不同的封装，功能类似的封装在一起。这样结构就清晰了很多。用的时候，找到对应的类就可以了。这就是面向对象的思想。 面向对象思想特点a:是一种更符合我们思想习惯的思想b:可以将复杂的事情简单化c:将我们从执行者变成了指挥者角色发生了转换 举例 洗衣服：换下脏衣服—找盆接水—泡一泡—手搓-----漂清----晾干 面向对象：找个对象（洗衣服）、全自动洗衣机（一键洗衣（调用方法）） 面向对象特征 封装(encapsulation) 继承(inheritance) 多态(polymorphism) 面向对象开发 ​ 就是不断的创建对象，使用对象，指挥对象做事情 类类就是一组相关属性和功能的集合，对象是该类事物的实例化，例如：学生的实例化之一为班长，班长就是学生类的一个对象。 成员变量和成员方法 定义类其实就是定义类的成员(成员变量和成员方法) 类的使用A:文件名问题在一个java文件中写两个类：一个基本的类，一个测试类。建议：文件名称和测试类名称一致。B:如何使用呢?创建对象使用。C:如何创建对象呢?格式：类名 对象名 = new 类名();D:如何使用成员变量呢?格式：对象名.变量名E:如何使用成员方法呢?格式：对象名.方法名(…) 案例： ​ 定义一个手机类并使用 12345678910111213141516171819202122232425262728293031323334353637//定义类public class Phone &#123; //成员变量：定义在类中，方法外 String name = &quot;小米&quot;; double price = 1000; String color = &quot;白色&quot;; //成员方法 public void call(String name) &#123; System.out.println(&quot;给&quot; + name + &quot;打电话&quot;); &#125; public void sendMsg(String name, String content) &#123; System.out.println(&quot;给&quot; + name + &quot;发短信，内容是&quot; + content); &#125;&#125;//使用该类public class TestPhone &#123; public static void main(String[] args) &#123; //类是一个抽象的概念，你无法直接使用，要使用类中的属性功能，必须创建该类对象 Phone phone=new Phone(); //获取属性 对象名.属性名 String name=phone.name; double price = phone.price; String color = phone.color; System.out.println(name); System.out.println(price); System.out.println(color); //使用功能：对象名.方法名() phone.call(&quot;张三&quot;); phone.sendMsg(&quot;张三&quot;,&quot;生日快乐&quot;); &#125;&#125; 成员变量和局部变量的区别 在类中的位置不同 成员变量：定义在类中方法外 局部变量：定义在方法中或方法声明上（形参） 在内存位置不同 成员变量：在堆内存中 局部变量：在栈内存中 生命周期不同 成员变量：随对象的创建而存在，随对象的消失而消失 局部变量：随方法的调用而存在，随方法的弹栈而消失 初始化值不同 成员变量：有默认初始化值 局部变量：无默认初始化值，必须赋值才能使用 注意事项：局部变量名称可以和成员变量名称一样，在方法中使用的时候，采用的是就近原则 方法的形式参数是类名的时候如何调用 Java中参数传递问题形式参数基本类型（四类八种）：形式参数的改变不影响实际参数引用类型：形式参数的改变直接影响实际参数 方法的参数是类名如果一个方法的形式参数是一个类类型(引用类型)，这里其实需要的是该类的对象。 匿名对象的概述和应用 匿名对象就是没有名字的对象 应用场景：对象的方法仅使用一次，也可作实际参数传递 12345678910public static void main(String[] args) &#123; //匿名对象调用方法 new Teacher().show(); //每new一次就是一个新的对象 new Teacher().show2(); new Teacher().show(); new Teacher().show(); //匿名对象调用成员变量 int num = new Teacher().num; System.out.println(num);&#125; 12345678910111213141516171819202122232425262728293031public class MyTest &#123; public static void main(String[] args) &#123; Cat cat = new Cat(); //如果你以后看到一个方法的形参，要一个 类 类型，那么你就传一个该类对象 cat.show(cat, 19); System.out.println(cat.num); System.out.println(&quot;---------------------&quot;); //匿名对象作为参数传递 //匿名对象可以作为参数传递 cat.show(new Cat(), 20); System.out.println(cat.num); &#125;&#125;class Cat &#123; int num = 100; public void show(Cat cat, int num) &#123; cat.num = num; System.out.println(cat.num);// &#125;&#125;输出：1919---------------------2019 封装 封装是指隐藏对象的属性和实现细节，仅对外提供公共访问方式 好处 隐藏实现细节，提供公共的访问方式 提高了代码的复用性 提高安全性 原则：将不需要对外提供的内容都隐藏起来，提供公共方法对其访问。 private关键字private是一个权限修饰符，可以修饰成员变量和成员方法，被其修饰只能在本类中被访问,提供get和set方法以供外界访问。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void sleep() &#123; System.out.println(&quot;睡觉&quot;); &#125; public void eat() &#123; System.out.println(&quot;吃饭&quot;); &#125;&#125;public class TestStudent &#123; public static void main(String[] args) &#123; Student student = new Student(); student.setName(&quot;张三&quot;); student.setAge(20); String name = student.getName(); int age = student.getAge(); System.out.println(&quot;姓名：&quot; + name + &quot;=== 年龄&quot; + age); student.eat(); student.sleep(); System.out.println(&quot;-------------------&quot;); Student student1 = new Student(); student1.setName(&quot;李四&quot;); student1.setAge(24); String name1 = student1.getName(); int age1 = student1.getAge(); System.out.println(&quot;姓名：&quot; + name1 + &quot;=== 年龄&quot; + age1); student1.eat(); student1.sleep(); &#125;&#125;//输出：姓名：张三=== 年龄20吃饭睡觉-------------------姓名：李四=== 年龄24吃饭睡觉]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组的定义及操作、递归]]></title>
    <url>%2F2019%2F04%2F08%2F%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%93%8D%E4%BD%9C%E3%80%81%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[数组概念：数组是存储同一种数据类型多个元素的集合。也可以看成是一个容器。 数组既可以存储基本数据类型，也可以存储引用数据类型 一维数组定义格式： 123格式一：数据类型[] 数组名；格式二：数据类型 数组名[]; 举例： 123int[ ] a; //定义了一个int类型的数组a；int a[ ]; //定义了一个int类型的数组a； 案例： 1234567891011121314151617181920212223242526public class ArrayDemo &#123; public static void main(String[] args) &#123; //数组：你可以一个容器，他用来存储一组相同类型的数据。 //数组的定义语法 //方式1：动态的定义方式，由我们规定数组的长度，由系统赋默认值 //创建一个int类型的数组 //当我们创建好了数组后，系统会给分配索引（角标）从0开始 int[] arr=new int[10]; //往数组中放入数据 通过数组的索引往里面存数据 arr[0]=10; arr[1]=20; arr[2]=30; //取数组中的元素 int num=arr[2]; System.out.println(num); System.out.println(arr[4]); System.out.println(arr[5]); //语法2 boolean bs[]=new boolean[2]; bs[0]=true; System.out.println(bs[0]); System.out.println(bs[1]); &#125;&#125; 数组可以存储基本数据类型，也可以存储引用数据类型。 1234567891011121314151617public class ArrayDemo &#123; public static void main(String[] args) &#123; int[] arr1 = new int[3]; arr1[0] = 10; arr1[1] = 20; System.out.println(arr1[1]); int[] arr2 = new int[3]; arr2[0] = 100; arr2[1] = 200; System.out.println(arr2[1]); System.out.println(arr1); System.out.println(arr2); //数据类型：基本数据类型和引用数据类型 //引用数据类型，你使用new关键字初始化的数据 数组 类 接口 枚举 Java中的内存分配以及栈和堆的区别 栈: 存放的是局部变量 局部变量：在方法定义中或者方法声明上的变量都是局部变量。 堆: 存放的是所有new出来的东西 特点： a: 每一个new出来的东西都会为其分配一个地制值。 b: 每一个变量都有一个默认的值 12345byte，short，int，long --------&gt;0float，double ----------------------&gt;0.0char –----------------------------------&gt;‘\u0000’boolean ------------------------------&gt; false引用数据类型------------------------&gt; null 使用完毕就变成了垃圾，等待垃圾回收器对其回收 方法区 本地方法区:(和系统相关) 寄存器:(cpu使用) 两个数组的内存图 三个数组的内存图 12345执行流程：定义第一个数组,定义完毕后，给数组元素赋值。赋值完毕后，再输出数组名称和元素定义第二个数组,定义完毕后，给数组元素赋值。赋值完毕后，再输出数组名称和元素定义第三个数组,把第一个数组的地址值赋值给它。(注意类型一致)，通过第三个数组的名称去把元素重新赋值最后，再次输出第一个数组数组名称和元素 数组的初始化Java中数组必须先初始化才能使用，即为数组中的元素分配内存空间并赋值 初始化的分类： ​ （1）动态初始化: 只指定长度，由系统给出初始化值 ​ （2）静态初始化: 给出初始化值，由系统决定长度 ​ 注意：两种初始化方式只能使用一种，不能动静结合 动态初始化格式： 1数据类型[] 数组名 = new 数据类型[数组长度]; 举例： 1int[] arr = new int[3]; //定义了一个int类型的数组arr，这个数组可以存放4个int类型的值。 动态初始化的内存图解 静态初始化格式： 1数据类型[] 数组名 = new 数据类型[]&#123;元素1,元素2,…&#125;; 举例： i 1int[] arr = new int[]&#123;1,2,3&#125;; 简化格式： 1数据类型[] 数组名 = &#123;元素1,元素2,…&#125;; 举例： 1int[] arr = &#123;1,2,3&#125;; 静态初始化内存图 12345678910public class ArrayDemo03 &#123; public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4 &#125;; // 静态初始化 // 下面的代码是依次访问数组中的元素 System.out.println(&quot;arr[0] = &quot; + arr[0]); System.out.println(&quot;arr[1] = &quot; + arr[1]); System.out.println(&quot;arr[2] = &quot; + arr[2]); System.out.println(&quot;arr[3] = &quot; + arr[3]); &#125;&#125; 一维数组常用操作数组的遍历1234567public static void main(String[] args) &#123; int[] arr=&#123;10,20,50,40,102&#125;; //数组的遍历 for(int i=0;i&lt;arr.length;i++)&#123; System.out.println(arr[i]); &#125;&#125; 数组获取最值12345678910111213141516public static void main(String[] args) &#123; //获取数组中的最大值或最小值 int[] arr = &#123;10, 20, 50, 40, 102&#125;; int max = getMax(arr); System.out.println(&quot;最大值是&quot; + max);&#125;public static int getMax(int[] arr)&#123; int max = arr[0]; for(int i = 1; i&lt;arr.length; i++)&#123; if(arr[i]&gt;arr[0])&#123; max = arr[i]; &#125; &#125; return max;&#125; 数组反转12345678910111213141516171819202122232425262728293031323334353637public class ArrayDemo3 &#123; public static void main(String[] args) &#123; //数组元素反转(就是把元素对调) int[] arr = &#123;10, 20, 30, 40, 50&#125;; //50 40 30 20 10 for (int i = 0, j = arr.length - 1; i &lt; j; i++, j--) &#123; int t = arr[i]; arr[i] = arr[j]; arr[j] = t; &#125; reverseArray(arr); showArray(arr); &#125; //数组元素反转 private static void reverseArray(int[] arr) &#123; //分析：首尾元素值交换，遍历一半 for (int i = 0; i &lt; arr.length / 2; i++) &#123; //采用中间变量进行值交换 int t = arr[i]; arr[i] = arr[arr.length - 1 - i]; arr[arr.length - 1 - i] = t; &#125; &#125; //遍历数组 private static void showArray(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + &quot;,&quot;); &#125; &#125;&#125; 数组查表法根据键盘录入索引,查找对应星期 123456789101112131415161718192021import java.util.Scanner;public class ArrayDemo8 &#123; public static void main(String[] args) &#123; //数组查表法(根据键盘录入索引, 查找对应星期) //根据索引查元素 String[] arr = &#123;&quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;, &quot;星期天&quot;&#125;; Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入一个整数 1----7&quot;); int index = scanner.nextInt(); String str = getElementByArray(index, arr); System.out.println(str); &#125; private static String getElementByArray(int index, String[] arr) &#123; if (index &gt;= 1 &amp;&amp; index &lt;= 7) &#123; return arr[index - 1]; &#125; else &#123; return &quot;查无此元素&quot;; &#125; &#125;&#125; 数组基本查找查找指定元素第一次在数组中出现的索引 12345678910111213141516171819202122import java.util.Scanner;public class ArrayDemo9 &#123; public static void main(String[] args) &#123; //根据元素查索引 String[] arr = &#123;&quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;, &quot;星期天&quot;&#125;; Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入一个星期&quot;); String str = scanner.nextLine();//获取用户输入的字符串 int index = getIndex(str, arr); System.out.println(&quot;该元素的索引是&quot; + index); &#125; private static int getIndex(String str, String[] arr) &#123; //遍历数组 for (int i = 0; i &lt; arr.length; i++) &#123; if (str.equals(arr[i])) &#123; return i; &#125; &#125; return -1; // 一般喜欢用 -1 代表没找到 &#125;&#125; 数组操作的两个常见小问题越界和空指针ArrayIndexOutOfBoundsException:数组索引越界异常每个数组的索引都有一个范围，即0~length-1。在访问数组的元素时，索引不能超出这个范围，否则程序会报错，如下所示。 123456public class ArrayDemo06 &#123; public static void main(String[] args) &#123; int[] arr = new int[4]; // 定义一个长度为4的数组 System.out.println(&quot;arr[0]=&quot; + arr[4]); // 通过角标4访问数组元素 &#125; &#125; 出现这个异常的原因是数组的长度为4，其索引范围为0~3，而上述代码中的第4行代码使用索引4来访问元素时超出了数组的索引范围。 NullPointerException:空指针异常在使用变量引用一个数组时，变量必须指向一个有效的数组对象，如果该变量的值为null，则意味着没有指向任何数组，此时通过该变量访问数组的元素会出现空指针异常 123456789public class ArrayDemo2 &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;10, 20&#125;; arr = null;// 人为置空 //NullPointerException 空指针异常 int length = arr.length; System.out.println(length); &#125;&#125; 二维数组概念：二维数组其实就是每一个元素为一维数组的数组 定义格式： 数据类型[][] 变量名 = new 数据类型[m][n] m表示这个二维数组有多少个一维数组 必须写上 n表示每一个一维数组的元素个数 可不写 举例： int[][] arr = new int[3][2]; 表示定义了一个二维数组arr，这个二维数组有3个一维数组，名称是arr[0],arr[1],arr[2]，每个一维数组有2个元素，可以通过arr[m][n]来获取 注意事项： （1）以下格式也可以表示二维数组： 数据类型 数组名[] [] = new 数据类型[m] [n]; 数据类型[] 数组名[] = new 数据类型[m] [n]; （2）int[] x,y[]; //定义了两个数组 一个是一维数组x= new int[3],另一个是二维数组y=new int[3] [] 二维数组的内存图 二维数组常用操作二维数组遍历12345678910public static void main(String[] args) &#123; int[][] arr = &#123;&#123;2, 4&#125;, &#123;10, 30&#125;, &#123;10, 30, 40&#125;, &#123;10, 1&#125;&#125;; //二维数组的遍历 for (int i = 0; i &lt; arr.length; i++) &#123; //System.out.println(arr[i]); //一维数组 for (int j = 0; j &lt; arr[i].length; j++) &#123; System.out.println(arr[i][j]); &#125; &#125;&#125; 打印杨辉三角1234567891011121314151617181920212223242526272829303132333435363738394041424344public class ArrayDemo &#123; public static void main(String[] args) &#123; //B: //需求：打印杨辉三角形(行数可以键盘录入) // //1 //1 1 //1 2 1 //1 3 3 1 //1 4 6 4 1 //1 5 10 10 5 1 // /** * 分析规律： * 1.每一行的第一个数和最后一个数都是1 * 2.从第三行开始，中间的数等于我上一行的前一列的数和我上一行本列的数之和 */ Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入行数&quot;); int n = sc.nextInt(); //1.第一个数和最后一个数都是1 //2.第三行开始，中间的数等于我上一行的前一列的数和我上一行本列的数之和 int[][] arr=new int[n][n]; //定义一个数组，行列数都一样 for (int i = 0; i &lt; arr.length; i++) &#123; arr[i][0]=1; //将每一行的第一个数，置成1 arr[i][i]=1; //将三角形的每一行的最后一个元素置成1 &#125; //计算中间元素 for (int i =2; i &lt; arr.length; i++) &#123; for (int j =1; j &lt;= i-1; j++) &#123; //第三行开始，中间的数等于我上一行的前一列的数和我上一行本列的数之和 arr[i][j]=arr[i-1][j-1]+arr[i-1][j]; &#125; &#125; //遍历二维数组 for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt;=i; j++) &#123; System.out.print(arr[i][j]+&quot;\t&quot;); &#125; System.out.println(); &#125; &#125;&#125; 递归递归概述: 方法定义中调用方法本身的现象递归注意事项： ​ 要有出口，否则就是死递归 ​ 次数不能太多，否则就内存溢出 斐波那契数列案例：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问第二十个月的兔子对数为多少？由此可见兔子对象的数据是：1 , 1 , 2 , 3 , 5 , 8 … 12345678910111213141516public class MyTest2 &#123; public static void main(String[] args) &#123; // 1 1 2 3 5 8 13 21 从第三个数开始，这个数等于前两个数之和 （斐波那契数列） //递归来做 int sum = sumRabbit(20); System.out.println(&quot;兔子的对数&quot; + sum); &#125; private static int sumRabbit(int i) &#123; if (i == 1 || i == 2) &#123; return 1; &#125; else &#123; return sumRabbit(i - 1) + sumRabbit(i - 2); &#125; &#125;&#125; 根据索引查元素1234567891011121314151617181920212223public class ArrayDemo8 &#123; public static void main(String[] args) &#123; //A: //案例演示: //数组查表法(根据键盘录入索引, 查找对应星期) //根据索引查元素 //获取跟打印输出是两个概念 String[] arr = &#123;&quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;, &quot;星期天&quot;&#125;; Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入一个整数 1----7&quot;); int index = scanner.nextInt(); String str = getElementByArray(index, arr); System.out.println(str); &#125; private static String getElementByArray(int index, String[] arr) &#123; if (index &gt;= 1 &amp;&amp; index &lt;= 7) &#123; return arr[index - 1]; &#125; else &#123; return &quot;查无此元素&quot;; &#125; &#125;&#125; 根据元素查索引1234567891011121314151617181920212223242526public class ArrayDemo9 &#123; public static void main(String[] args) &#123; //ctrl+alt+O 优化导包，没有的包导进来，没有用到的包删掉 //根据元素查索引 String[] arr = &#123;&quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;, &quot;星期天&quot;&#125;; Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入一个星期&quot;); String str = scanner.nextLine();//获取用户输入的字符串 int index = getIndex(str, arr); System.out.println(&quot;该元素的索引是&quot; + index); &#125; private static int getIndex(String str, String[] arr) &#123; //遍历数组 for (int i = 0; i &lt; arr.length; i++) &#123; if (str.equals(arr[i])) &#123; return i; &#125; &#125; return -1; // 一般喜欢用 -1 代表没找到 &#125;&#125; 在数组中查元素索引123456789101112131415161718public class Test &#123; public static void main(String[] args) &#123; int[] arr=new int[]&#123;11,32,55,47,55,79,23&#125;; int num = 55; int index = getIndex(num,arr); System.out.println(index); &#125; private static int getIndex(int num,int[] arr)&#123; for (int i=0;i&lt;arr.length;i++)&#123; if(num==arr[i])&#123; return i; &#125; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[键盘录入数据、流程控制语句、方法、方法重载]]></title>
    <url>%2F2019%2F04%2F05%2F%E9%94%AE%E7%9B%98%E5%BD%95%E5%85%A5%E6%95%B0%E6%8D%AE%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[键盘录入1、在类（class）上面导包 ​ 格式： 1import java.util.Scanner; 2、创建键盘录入对象 ​ 格式： 1Scanner sc = new Scanner(System.in); 3、通过对象的方法获取键盘录入的数据 123int x = sc.nextInt();String str = sc.nextLine();... Java语言三种结构Java语言三种结构：顺序结构、选择结构、循环结构 顺序结构是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的，即写在前面的先执行，写在后面的后执行，从上往下，依次执行。 1234System.out.println(&quot;a&quot;);System.out.println(&quot;b&quot;);System.out.println(&quot;c&quot;);//顺序结构，自上而下执行，依次输出a,b,c 选择结构选择结构包括if语句和switch语句 if语句​ 格式一： 123if(boolean类型的表达式或值)&#123; 语句体 //当()内表达式为true时进入大括号执行语句体&#125; ​ 案例： 1234if(4&gt;3)&#123; System.out.println(&quot;执行的该语句&quot;);&#125;// 控制台会打印出&quot;执行的该语句&quot; ​ 格式二： 12345if(条件)&#123; 条件为真，执行这个括号里面的代码&#125;else&#123; 条件为假，执行这个括号里面的代码&#125; ​ 案例： 123456if(10+2&gt;5-3)&#123; System.out.println(&quot;这是真的&quot;);&#125;else&#123; System.out.println(&quot;这是假的&quot;);&#125;// 运行结果为&quot;这是真的&quot; ​ 三元运算符能实现的，都可以采用if语句实现，但反之不成立 ​ 什么时候if语句实现不能用三元改进呢? 当if语句控制的操作是一个输出语句的时候就不能改写 ​ 格式三： 123456789if(条件1)&#123; 语句体1 //满足条件1则执行此处&#125;else if(条件2)&#123; 语句体2 //满足条件2则执行此处&#125;...else&#123; 语句体n+1 //条件1、2、...n都不满足则执行此处语句&#125; ​ 案例：获取三个数最大值 1234567891011int a=100;int b=10;int c=18;if(a&gt;b&amp;&amp;a&gt;c)&#123; max=a;&#125;else if(b&gt;a&amp;&amp;b&gt;c)&#123; max=b;&#125;else&#123; max=c;&#125; System.out.println(&quot;最大值是：&quot;+max); switch语句12345678910111213141516switch(常量/变量)&#123; case 值: 执行的代码 break; case 值: 执行的代码 break; case 值: 执行的代码 break; case 值: 执行的代码 break; default: 执行的代码 break; 注意： 1、switch语句支持的表达式的数据类型：byte 、short、 int、 char、JDK5以后可以是枚举、JDK7以后可以是String 2、case 后面的只能是常量，多个case后面的值不能出现相同的 3、default 可以写也可以不写，且功能的执行与位置无关，但是建议在最后，当所有case项都没有匹配上就会执行 4、break 结束整个switch语句，如果没有 break 会发生 case穿透，这种现象你可以利用 5、switch语句的结束条件：遇到break就结束了或者执行到末尾结束 案例一： 123456789101112131415161718192021222324int x = 2;int y = 3;switch(x)&#123;default: y++;case 3: y++;case 4: y++;&#125;System.out.println(&quot;y=&quot;+y);//6-----------------------------------------------------int x = 2;int y = 3;switch(x)&#123;default: y++;break;case 3: y++;case 4: y++;&#125;System.out.println(&quot;y=&quot;+y); // 4 循环结构循环结构包括for循环、while循环和do…while循环 for循环123for(初始化表达式语句;判断条件语句;控制条件语句) &#123; 循环体语句;&#125; 执行流程： a:执行初始化表达式语句 b:执行判断条件语句,看其返回值是true还是false，如果是true，就继续执行，如果是false，就结束循环 c:执行循环体语句 d:执行控制条件语句 e:回到b继续执行 注意：初始化表达式语句只执行一次 案例：打印1~100的数 123for(int i=1; i&lt;=100; i++)&#123; System.out.println(i)&#125; while循环1234while(判断条件语句) &#123; 循环体语句; 控制条件语句;&#125; 执行流程：先判断条件语句是否为true，若为true，则进入大括号执行循环语句和控制条件语句 案例：求1—100之间的和 1234567int i=1;int sum=0;while (j&lt;=100)&#123; sum+=j; j++;&#125;System.out.println(&quot;和是 &quot;+sum); do …while循环1234do &#123; 循环体语句; 控制条件语句;&#125;while(判断条件语句); 执行流程：先执行do里面的代码一次，然后再去判断，while括号里面的条件是否成立，如果成立，就继续执行{}里面的语句，如果条件不成立，则循环结束 案例： 123456int i=2;do&#123; System.out.println(&quot;你好&quot;); i--;&#125;while (i&gt;2); //执行一次do里面的代码 三种循环语句的区别 (1): do…while循环至少执行一次循环体。而for,while循环必须先判断条件是否成立，然后决定是否执行循环体语句。 (2): 如果你想在循环结束后，继续使用控制条件的那个变量，用while循环，否则用for循环。 死循环 当控制条件语句控制的那个变量丢失时，循环结构可能进入死循环 两种最简单的死循环格式: ​ while(true){…} ​ for(; ; ){…} 控制跳转语句什么是控制跳转语句：Java中的goto是保留字，目前不能使用。虽然没有goto语句可以增强程序的安全性，但是也带来很多不便， 比如想在某个循环执行到某一步的时候就结束，现在就做不了这件事情。为了弥补这个缺陷，Java就提供了break（中断），continue（继续）和return（返回）来实现控制语句的跳转和中断 break(1):在选择结构switch语句中 (2):在循环语句中 ​ 作用：常用于退出单层循环 ​ 注意：离开使用场景的存在是没有意义的 continue​ 在循环语句中 ​ 作用：跳出一次循环，执行下一步操作 ​ 注意：离开使用场景的存在是没有意义的 案例： 12345678910for(int x=1; x&lt;=10; x++) &#123; if(x%3==0) &#123; //在此处填写代码 &#125; System.out.println(“Java”);&#125; //我想在控制台输出2次:“Java“----braak;//我想在控制台输出7次:“Java“----continue;//我想在控制台输出13次:“Java“----System.out.println(“Java”); return​ 作用：return 就是退出一个方法 方法​ 为了解决代码重复编写的问题，可以将一个功能的代码提取出来放在一个{}中，并为这段代码起个名字，所提取出来的代码可以被看作是程序中定义的一个方法，就是对一段功能逻辑的封装，以实现重复调用。 格式 1234修饰符 返回值类型 方法名(参数类型 参数名1，参数类型 参数名2 …)&#123; 方法体; return 返回值;&#125; 举例：定义一个方法求1~n的和并返回值 123456public static int getSum(int n)&#123; int sum=0; for(int i = 1; i&lt;=n; i++)&#123; sum+=i; &#125;&#125; 主方法 1public static void main(String[] args) &#123;&#125; 主方法是一个程序的入口，主方法是JVM来调用的，一个类中只能有一个主方法 实参与形参 实参：调用方法时，传入的参数，叫做实际参数，简称实参，传常量，变量都可以。 形参：定义方法括号里面的参数，叫做形式参数，简称形参。形参的作用是，调用方法时，接收传过来的实参，多个形参你用逗号隔开。 注意 12345方法不调用不执行方法与方法是平级关系，不能嵌套定义方法定义的时候参数之间用逗号隔开方法调用的时候不用在传递数据类型如果方法有明确的返回值，一定要由return带回一个值 案例 123456789101112131415161718192021// 需求：根据键盘录入的数据输出对应的乘法表import java.util.Scanner;public class MyTest &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入一个行数&quot;); int i = sc.nextInt(); //调用方法 showChengFaBiao(i); &#125; public static void showChengFaBiao(int a) &#123; for (int i = 1; i &lt;= a; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; System.out.print(j + &quot;*&quot; + i + &quot;=&quot; + (j * i) + &quot;\t&quot;); &#125; System.out.println(); &#125; &#125;&#125; 方法重载在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同（参数个数或者参数类型不同），与返回值无关。调用的时候，会根据参数个数和参数类型去匹配。 1234567891011121314151617181920private static int add(int i, int i1) &#123; System.out.println(&quot;两个int参数方法调用了&quot;); return i + i1; &#125; private static double add(int i, double i1) &#123; System.out.println(&quot;一个int 一个double调用了&quot;); return i + i1; &#125; private static int add(int i, int i1, int i2, int i3) &#123; return i + i1 + i2 + i3; &#125; private static int add(int i, int i1, int i2) &#123; return i + i1 + i2; &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进制、常量、变量、数据类型、运算符]]></title>
    <url>%2F2019%2F04%2F02%2F%E8%BF%9B%E5%88%B6%E3%80%81%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[进制二进制：由0、1组成，逢二进一，以0b开头， 八进制：由0~7组成，逢八进一，以0开头 十进制：由0~9组成，逢十进一，默认是十进制 十六进制：由0-9,A-F组成，逢十六进一，以0X开头 案例：输出不同进制表现10的数据二进制：0b10八进制：010十进制：10十六进制：0x10 任意进制到十进制的转换规则：系数*基数^权数次幂相加 1二进制转换为十进制：0b101----&gt; 1*2^0+0*2^1+1*2^2=5 其他进制转换到十进制以此类推 十进制到任意进制的转换规则：除基取余 直到商为0 余数反转 十进制转换为二进制： 5/2商2余1 2/2商1余0 1/2商0余1 余数反转（自下而上）的二进制为:0b101 原码 反码 补码原码：即二进制定点表示法 反码：正数的反码与其原码相同；负数的反码是除符号位外对其逐位取反 补码：正数的补码与其原码相同；负数的补码是在其反码的末位加1 案例： ​ 原码：1001011 ​ 反码：1110100（除符号位外对位取反） ​ 补码：1110101（反码加1） 变量什么是变量 在程序执行的过程中，在某个范围内其值可以发生改变的量，定义一个变量，其实就是开辟了一个内存空间 变量本质上是内存中的一块空间，这块空间“有数据类型”、“有名字”、“有字面值” 变量包括：数据类型 名字 字面值； 变量是内存中存储数据的最基本的单元 数据类型的作用：指导数据在内存中开辟多大的空间 不同的数据有不同的类型，不同的数据类型底层会分配不同大小的空间 数据类型是指导程序在运行阶段应该分配多大的内存空间 变量要求：变量中存储的具体的“数据”必须和变量的“数据类型”一致 定义格式 数据类型 变量名 = 变量值 变量声明后怎么赋值变量名 = 字面值； =等号是一个运算符，叫做赋值运算符，赋值运算符先运算等号右边的表达式，表达式执行结束后的结果赋值给左边的变量。 声明和赋值可以放到一起完成 1int i = 10； 变量赋值之后可以重新赋值，变量的值可变化123456int i = 10；System.out.println(i); //10i = 20;System.out.println(i); //20i = 30;System.out.println(i); //30 有了变量的概念之后，内存空间得到了重复的使用 通常访问一个变量包括两种访问形式 第一种：读取变量中保存的具体数据 get/获取 第二种：修改变量中保存的具体数据 set/设置 12i = 20; //setSystem.out.println(i); //get 变量在一行上可以声明多个1234int a,b,c//一行上可以同时声明多个变量 int a,b,c=300;//这一行说明只是给c赋值了，a,b并没有 变量必须先声明，再赋值，才能访问1234567891011public class Varible &#123; public static void main (String[] args)&#123; int i； //程序执行到这里，内存空间没有开辟出来，变量i并没有初始化 //所以没有赋值之前是无法访问的 // System.out.println(i); //编译报错 //给i赋值，完成初始化，内存开辟 i = 100； System.out.println(i);//100 &#125; &#125; *变量的分类根据变量声明的位置来分类： 局部变量​ 在方法体当中声明的变量叫做局部变量 成员变量​ 在方法体外（类体内）声明的变量叫成员变量 在不同作用域中，变量名可以相同，就近原则 数据类型 不同数据数据类型的数据占用空间大小不同。 数据类型作用是指导JVM在运行程序时给数据分配多大的内存空间。 Java中数据类型的分类： ​ 基本数据类型 ​ 引用数据类型 基本数据类型整数型12345类型 字节数 范围byte 1(8bit) -128 ~ 127short 2(16bit) -2^15 ~ 2^15 - 1int 4(32bit) -2^31 ~ 2^31 - 1long 8(64bit) -2^63 ~ 2^63 - 1 浮点型123类型 字节数 范围float 4(32bit) -3.403*10^38 ~ 3.403*10^38double 8(64bit) -1.798*10^308 ~1.798*10^308 字符型12类型 字节数 范围char 2(16bit) 0 ~ 2^16 - 1 = 65535 ​ 换行符 \n 制表符 \t 布尔型12类型 字节数 boolean 1 整数默认是int类型的 ， 浮点数默认是 double类型的 引用数据类型如数组，接口，类等 注意： ​ 未初始化的变量不能使用​ 同一作用域内不能有两个同名变量​ 同一行可定义多个变量，但不建议 java数据类型的自动类型提升与强制转换自动类型提升byte short char 在参与数学运算时，会自动提升为int类型，如果还有long ,float double 参与运算则会相应的提升为 long float double ,布尔类型不参与数学运算，byte short char 之间不发生转换 12345byte a=10;short b=20;byte num=a+b; //报错,在运算时会转换为int类型，byte类型的num装不下int类型的数据a=a+1;//报错，1为int类型 强制类型转换强制将一个数据，转换成我们要的数据类型，强制类型转换，有可能会发生精度损失的问题 格式：目标数据类型 变量名=(目标数据类型)(被转换的数据); 1234byte a = 1;byte b = 127;short c =(short) a+b;//运算时虽然自动转换为int类型，但强制转换为short，且128在short数据类型范围内，此处不会发生精度损失byte c = (byte)128;//输出-128 案例 12345byte a=10;byte b=20;byte r=a+1; //报错，int转为byte可能发生精度损失byte rr=3+4; //不会报错 常量优化机制，多个常量相加时，他会先算出结果，看没有在这个数据类型的范围内，如果在，就不报错,如果不在就会报错char ch=&apos;爱&apos;; //char 占两个字节，gbk编码一个汉字占两个字节 ANSI 也是一个汉字占两个字节，UTF8 一个汉字占三个字节的 字符和字符串参与运算ASCII码表中: ‘a’97 ‘A’ 65 ‘0’ 48 123char ch = &apos;a&apos;;char ch2 = ch+1;//报错，从int转换到char可能会有精度损失int r = ch+1;//不报错，输出98 当+号运算两端只要任意一端是一个字符串，那么加号就起连接符的作用，就会将两端的内容拼接起来，形成一个新的字符串 1234567System.out.println(&quot;Hello World!&quot;+100); //&quot;Hello World!100&quot;System.out.println(&quot;Hello World!&quot;+100+86);//&quot;Hello World!10086&quot;System.out.println(&quot;Hello World!&quot;+&quot;10086&quot;);// &quot;Hello World!10086&quot; System.out.println(10086+&quot;Hello World!&quot;);//&quot;10086Hello World!&quot;System.out.println(100+&quot;Hello World!&quot;+100+86);//100Hello World!10086System.out.println(100+86+&quot;Hello World!&quot;+100+86); //186HelloWorld!10086System.out.println(&quot;5+5=&quot;+5+5);//&quot;5+5=55&quot;System.out.println(5+5+&quot;=5+5&quot;);//&quot;10=5+5&quot; 运算符 什么是运算符:对常量和变量进行操作的符号称为运算符 运算符的分类: 123456算术运算符 赋值运算符比较运算符逻辑运算符位运算符三目运算符 注意事项： a:整数相除只能得到整数。如果想得到小数，请使用浮点数 b:/获取的是除法操作的商，%获取的是除法操作的余数 %运算结果的符号，取决于参与运算是左边的符号。 算数运算符 算数运算符有哪些:+ , - , * , / , % , ++ , – /：整数相除只能得到整数，要得到小数需使用服浮点数 ++:自加,对原有的数据进行+1–:自减,对原有的数据进行-1 ++,–运算符单独使用：放在操作数的前面和后面效果一样 ++,–参与运算时使用：放在操作数的前面，先自增或者自减，然后再参与运算 放在操作数的后面，先参与运算，再自增或者自减 案例 1234567int a = 3;a++;//此处a=4++a;//此处a=5a--;//a=4--a;//a=3int num = a++; //num=3 a=4int num2 = ++a; //num2=5 a=5 赋值运算符赋值运算符有哪些：=， +=,-=,*=,/=,%= 案例： 123byte b =3;b = b+1; //报错b+=1; //不报错，会自动强制类型转换，然后判断累加完的结果，在不在这个数据类型的范围内，如果不在会自动强制类型转换 比较运算符关系运算符有哪些：== ,!= , &lt; , &gt; , &lt;= , &gt;= 关系运算符运算结果是booean型 逻辑运算符逻辑运算符有哪些：&amp;(并且) , |(或者) , !(非) , ^(异或) , &amp;&amp;(短路与) , ||(短路或) 逻辑运算符运算结果是booean型 &amp;(并且) , |(或者) 和 &amp;&amp;(短路与) ,||(短路或) 在运算结果上没有区别，区别在运算效率上：&amp;，运算符两端都会计算，而&amp;&amp;，||只要左端能得出计算结果，则不会执行右端 案例： 1234int a = 1;int b = 2;boolean flag = a==2 &amp;&amp; (a&gt;b);//&amp;&amp;左端已经为false，则右端不会再进行判断System.out.println() 三元运算符语法：布尔表达式?结果1:结果2 案例：求两个数最大值 123int a = 1;int b = 2;int max = a&gt;b?a:b; 位运算符位运算符有哪些： ​ &amp;(与)，|(或)，^(异或) , ~(按位取反) , &lt;&lt;(左移) ,&gt;&gt;(右移) ,&gt;&gt;&gt;(无符号右移) &amp;:有0则0|:有1则1^:相同则0，不同则1~:按位取反 0变1 1变0 &lt;&lt; : 把&lt;&lt;左边的数据乘以2的移动次幂 例如 10&lt;&lt;3 结果 10*2^3=80 12345int flag = 1&amp;2; //0int flag = 1|2; //3int flag = ~3; //-4int num = 3&gt;&gt;2; //3/2^2=0int num = 3&lt;&lt;2; //3*2^2=12]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java简介、注释、、常见DOS命令]]></title>
    <url>%2F2019%2F04%2F01%2FJava%E7%AE%80%E4%BB%8B%E3%80%81%E6%B3%A8%E9%87%8A%E3%80%81%E3%80%81%E5%B8%B8%E8%A7%81DOS%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一、DOS常用命令 DOS命令 功能 cd + 目录名 进入该目录 cd… 回退上一级目录 cd…/…/ 回退上两级目录 cd /盘符 + 完整路径名 跨盘操作 md + 目录名 新建一个目录 rd + 目录名 删除一个空目录 rd /s + 目录名 删除非空目录，删除前会确认是否删除 rd /s /q + 目录名 删除非空目录，直接删除 del + 文件名.后缀名 删除该文件 del + *.后缀名 删除该目录下所有该后缀名的文件 mspaint 打开画图 calc 打开计算器 cls 清屏 exit 退出 hsotname 查看主机名 ipconfig 查看IP地址 shutdow -s -t 0 在0秒后关机 二、JDK JRE JVMJDK：java开发工具包，提供给开发人员编写java程序JRE：java运行环境，源代码由JRE运行JVM：java虚拟机，实现跨平台注：JDK包含JRE，使用JDK开发java程序，交给JRE运行，由JVM实现跨平台 三、Java的三种注释//单行注释 /多行注释 / /*文档注释 / 四、标识符给类，变量等起的名字不能以数字开头可使用的符号：_ $见名知意给类命名首字母大写，多个字母采用驼峰式命名，如StudentName 五、常量定义：在程序中值不会发生的量称作常量，分为字面值常量和自定义常量字面值常量： 整数常量（1 2 3…）小数常量（1.1 …）字符常量（‘a’ ‘A’ ‘1’…）注：单引号括起来的一个字符字符串常量（“String” “1” “A”）注：用双引号括起来的一个或多个字符布尔常量（true false） 空常量（null） 六、关键字的概述和使用A:什么是关键字 就是被java语言赋予特殊含义的单词。B:关键字的特点 组成关键的字母都是小写C:常见关键字 class,public,static,void …..D:关键字的注意事项 (1): goto和const是java语言的保留字 (2): 类似与editplus这样的高级文本编辑器对关键字都是有颜色变化的 七、标识符的概述和组成规则“见名知意”A:什么是标识符 就是给类,接口,方法,变量,常量等起名字时使用的字符序列B:标识符的组成规则 (1): 英文的大小写字母 (2): 数字字符 (3): $和_C:标识符注意事项 (1): 不能以数字开头 (2): 不能是java中的关键字 (3): 区分大小写]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欢迎访问我的博客！]]></title>
    <url>%2F2019%2F03%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[技术博客、人生感悟、随便写写。 大家笑一笑就好！]]></content>
  </entry>
</search>
