<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面向对象【五】(抽象类、接口)</title>
      <link href="/2019/04/18/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%90%E4%BA%94%E3%80%91(%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3)/"/>
      <url>/2019/04/18/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%90%E4%BA%94%E3%80%91(%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3)/</url>
      
        <content type="html"><![CDATA[<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><h2 id="抽象类的概述"><a href="#抽象类的概述" class="headerlink" title="抽象类的概述"></a>抽象类的概述</h2><p>回想前面我们的猫狗案例，提取出了一个动物类。并且我们在前面也创建过了动物对象，其实这是不对的。<br>为什么呢?因为，我说动物，你知道我说的是什么动物吗?只有看到了具体的动物，你才知道，这是什么动物。<br>所以说，动物本身并不是一个具体的事物，而是一个抽象的事物。只有真正的猫，狗才是具体的动物。<br>同理，我们也可以推想，不同的动物吃的东西应该是不一样的，所以，我们不应该在动物类中给出成员方法的具体体现，而是应该给出一个声明即可。</p><p>在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类。</p><h2 id="抽象类的特点"><a href="#抽象类的特点" class="headerlink" title="抽象类的特点"></a>抽象类的特点</h2><ul><li>抽象类和抽象方法必须用<code>abstract</code>关键字修饰</li></ul><h2 id="格式"><a href="#格式" class="headerlink" title="格式:"></a>格式:</h2><p>抽象类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abstract class 类名 &#123;&#125;；</span><br></pre></td></tr></table></figure><p>抽象方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract void eat();</span><br></pre></td></tr></table></figure><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ul><li><p>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</p></li><li><p>问：抽象类中可以有构造方法,抽象类不能进行实例化,那么要构造方法有什么作用呢?</p><p>答：用于子类访问父类数据时的初始化</p></li><li><p>问：抽象类不能直接实例化那么，抽象类如何实例化呢?</p><p>答：按照多态的方式，由具体的子类实例化。其实这也是多态的一种，抽象类多态。</p></li></ul><ul><li><p>抽象类的子类</p><p>要么是抽象类<br>要么重写抽象类中的所有抽象方法</p></li></ul><p>代码示例：（以下代码是自定义类）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//一旦一个类中，有了抽象方法，此类必须为抽象类</span><br><span class="line"></span><br><span class="line">public abstract class Animal &#123;</span><br><span class="line">    public Animal() &#123;</span><br><span class="line">        System.out.println(&quot;父类的构造方法执行了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //abstract 抽象的，可以修饰类，修饰方法</span><br><span class="line">    public abstract void eat(); //抽象方法，此方法没有方法实现</span><br><span class="line"></span><br><span class="line">    public abstract void sleep();</span><br><span class="line">    //抽象类中既可以有抽象方法，也可以非抽象方法</span><br><span class="line">    public void show()&#123;</span><br><span class="line">        System.out.println(&quot;这是父类的一个非抽象方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Cat extends Animal&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;     //对父类中的抽象方法进行重写，子类如果不是抽象类，必须对父类中的所有抽象方法进行重写</span><br><span class="line">        System.out.println(&quot;猫爱吃鱼&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sleep() &#123;</span><br><span class="line">        System.out.println(&quot;猫白天睡觉&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一旦一个类中，有了抽象方法，此类必须为抽象类</strong></p><p><strong>对父类中的抽象方法进行重写，子类如果不是抽象类，必须对父类中的所有抽象方法进行重写</strong></p><p>以下代码是测试类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //new Animal();</span><br><span class="line">        //抽象类不能直接创建对象</span><br><span class="line">        //我们可以采用多态间接的去实例化抽象类</span><br><span class="line">        Animal an=new Cat();</span><br><span class="line">        an.eat();</span><br><span class="line">        an.sleep();</span><br><span class="line">        an.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试类中的主方法中的第一行代码执行时，用到了多态，那么最终运行结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">父类的构造方法执行了</span><br><span class="line">猫爱吃鱼</span><br><span class="line">猫白天睡觉</span><br><span class="line">这是父类的一个非抽象方法</span><br></pre></td></tr></table></figure><h2 id="抽象类的成员特点及注意事项"><a href="#抽象类的成员特点及注意事项" class="headerlink" title="抽象类的成员特点及注意事项"></a>抽象类的成员特点及注意事项</h2><h3 id="成员特点"><a href="#成员特点" class="headerlink" title="成员特点"></a>成员特点</h3><ol><li><p>成员变量：既可以是变量，也可以是常量。</p></li><li><p>构造方法：有，用于子类访问父类数据的初始化。</p></li><li><p>成员方法：既可以是抽象的，也可以是非抽象的。</p></li><li><p>抽象类的成员方法特性：</p><p>抽象方法：    强制要求子类重写的事情。<br>非抽象方法： 子类继承的事情，提高代码复用性。</p></li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>抽象类，就是被abstract所修饰的类，父类将所有子类的共性功能向上抽取后，他并不知道，每个子类对这个共性功能的具体实现，所以没有必要在父类中，给出共性功能的具体实现，而是给出声明即可，所谓给出功能的声明，就是将此功能抽象出来，然后强制子类必须重写。</li></ul><ul><li>抽象类注意的事项：一旦一个类中，有了抽象方法，那么此类必须为抽象类</li></ul><ul><li>一个抽象类中可以没有抽象方法</li></ul><ul><li>抽象类中既可以有抽象方法，也可以有非抽象方法，抽象方法，强制子类重写；非抽象方法，可以让子类继承下去用</li></ul><ul><li>抽象类不能直接实例化，可以采用多态的方式，间接实例化</li></ul><ul><li>抽象类的子类，要么重写父类中所有的抽象方法，要么自己也是一个抽象类。</li></ul><ul><li>抽象类中有构造方法，用来子类初始化父类要用</li></ul><p>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person p = new Student();</span><br><span class="line">        p.name = &quot;赵某某&quot;;</span><br><span class="line">        p.age = 20;</span><br><span class="line">        System.out.println(p.name + &quot;====&quot; + p.age);</span><br><span class="line">        p.sleep();</span><br><span class="line">        p.playGame();</span><br><span class="line">        p.eat();</span><br><span class="line">        ((Student) p).watchTV();</span><br><span class="line">        System.out.println(&quot;------------------------&quot;);</span><br><span class="line">        p = new Teacher();</span><br><span class="line">        p.name = &quot;沈某某&quot;;</span><br><span class="line">        p.age = 21;</span><br><span class="line">        System.out.println(p.name + &quot;===&quot; + p.age);</span><br><span class="line">        p.eat();</span><br><span class="line">        p.playGame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Person &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public int age;</span><br><span class="line">    public abstract void eat();</span><br><span class="line">    public abstract void sleep();</span><br><span class="line">    public void playGame()&#123;</span><br><span class="line">        System.out.println(&quot;玩游戏&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;学生爱吃烤串&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sleep() &#123;</span><br><span class="line">        System.out.println(&quot;学生通宵不寐&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void watchTV()&#123;</span><br><span class="line">        System.out.println(&quot;学生看电视&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Teacher extends Person &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;老师爱吃米饭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sleep() &#123;</span><br><span class="line">        System.out.println(&quot;老师经常失眠&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中使用到了向下转型，代码最终运行结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">赵某某====20</span><br><span class="line">学生通宵不寐</span><br><span class="line">玩游戏</span><br><span class="line">学生爱吃烤串</span><br><span class="line">学生看电视</span><br><span class="line">-------------</span><br><span class="line">沈某某===21</span><br><span class="line">老师爱吃米饭</span><br><span class="line">玩游戏</span><br></pre></td></tr></table></figure><h2 id="抽象类中的面试题"><a href="#抽象类中的面试题" class="headerlink" title="抽象类中的面试题"></a>抽象类中的面试题</h2><ul><li><p>面试题1：<br>一个类如果没有抽象方法，可不可以定义为抽象类?如果可以，有什么意义?<br>答案: 可以 . 不能创建对象.因为抽象类不能实例化</p></li><li><p>面试题2：<br>abstract不能和哪些关键字共存?<br>private 冲突<br>final 冲突</p><p>static 不能共存 无意义</p></li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="接口的概述"><a href="#接口的概述" class="headerlink" title="接口的概述"></a>接口的概述</h2><p>为了体现父类功能的扩展性，Java中就提供了接口来定义这些额外的拓展功能，并不给出具体实现，将来哪些子类需要使用到这些额外功能，只需要把这部分额外功能实现即可</p><h2 id="接口特点"><a href="#接口特点" class="headerlink" title="接口特点"></a>接口特点</h2><ul><li><p>接口用关键字interface表示    </p><p>格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名 &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>类实现接口用implements表示    </p><p>格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 类名 implements 接口名 &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>接口不能实例化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">那么，接口如何实例化呢? </span><br><span class="line">  按照多态的方式来实例化。</span><br></pre></td></tr></table></figure></li><li><p>接口的子类</p><p>可以是抽象类。但是意义不大。<br>可以是具体类。要重写接口中的所有抽象方法。(推荐方案)</p></li></ul><p>代码示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        Animal an = cat;</span><br><span class="line">        an.eat();</span><br><span class="line">        // CalcInterface 是猫的一个父接口，所以猫类也可以看成是父接口的一个子类</span><br><span class="line">        CalcInterface calcInterface = cat; //接口不能直接实例化，但是可以使用多态类实例化</span><br><span class="line">        calcInterface.calc();</span><br><span class="line">        //多态</span><br><span class="line">        CalcInterface c = new Dog();</span><br><span class="line">        c.calc();</span><br><span class="line">        //接口不能new 对象</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Animal &#123;</span><br><span class="line"></span><br><span class="line">    public abstract void eat();</span><br><span class="line">&#125;</span><br><span class="line">interface CalcInterface &#123;</span><br><span class="line">    //用来定义额外功能</span><br><span class="line">    public abstract void calc(); //接口中的方法只能是抽象类，即只需要声明，不需要具体实现，</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal implements CalcInterface&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;        //重写抽象类中的抽象方法</span><br><span class="line">        System.out.println(&quot;猫吃鱼&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void catcheMouse()&#123;      子类猫类的特有方法</span><br><span class="line">        System.out.println(&quot;猫抓老鼠&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void calc() &#123;    //因为接口中的方法只能是抽象方法，所以实现接口时必须对抽象方法进行实现</span><br><span class="line">        System.out.println(&quot;猫经过不断的努力学习，会做算术了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal implements CalcInterface&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;狗吃骨头&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void lookDoor()&#123;</span><br><span class="line">        System.out.println(&quot;狗看门&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void calc() &#123;</span><br><span class="line">        System.out.println(&quot;狗经过自己的学习，也学会了做算术&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">猫吃鱼</span><br><span class="line">猫经过不断的努力学习，会做算术了</span><br><span class="line">狗经过自己的学习，也学会了做算术</span><br></pre></td></tr></table></figure><h2 id="接口的成员特点"><a href="#接口的成员特点" class="headerlink" title="接口的成员特点"></a>接口的成员特点</h2><ol><li>成员变量；只能是常量，并且是静态的；默认修饰符：<code>public static final</code>；建议：自己手动给出。</li><li>构造方法：接口没有构造方法。</li><li>成员方法：只能是抽象方法；默认修饰符：<code>public abstract</code>；建议：自己手动给出。</li></ol><p>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //接口中成员变量的特点</span><br><span class="line">        //接口中的成员变量全是静态的公共常量</span><br><span class="line">        //接口中没有构造方法的</span><br><span class="line">        //接口中没有非抽象方法，全是抽象方法</span><br><span class="line"></span><br><span class="line">        int a = A.A;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        int num = A.num;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface A&#123;</span><br><span class="line">    //接口中成员变量前面有默认的修饰符  public static final</span><br><span class="line">    int num=100;</span><br><span class="line">    public static final  int A=1000;</span><br><span class="line"></span><br><span class="line">   //方法前面存在默认修饰符 public abstract</span><br><span class="line">    public abstract void hehe();</span><br><span class="line">    void test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类与类-类与接口-接口与接口的关系"><a href="#类与类-类与接口-接口与接口的关系" class="headerlink" title="类与类,类与接口,接口与接口的关系"></a>类与类,类与接口,接口与接口的关系</h2><ol><li>类与类：继承关系,只能单继承,可以多层继承。</li><li>类与接口：实现关系,可以单实现,也可以多实现。并且还可以在继承一个类的同时实现多个接口。</li><li>接口与接口：继承关系,可以单继承,也可以多继承。</li></ol><p>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //类跟类之间的关系</span><br><span class="line">        // 类跟类是继承关系，只能是单继承，支持多层继承</span><br><span class="line">        // 类跟接口是实现关系 既可以实现一个接口，也可以实现多个接口,实现接口，必须重写接口中所有的抽象方法</span><br><span class="line">        // 接口跟接口的关系，继承关系，而且可以多继承</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fu&#123;&#125;</span><br><span class="line">interface A&#123;</span><br><span class="line"></span><br><span class="line">    void a();</span><br><span class="line">&#125;</span><br><span class="line">interface C&#123;</span><br><span class="line">    void c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends Fu implements A,C&#123;       类与接口可以多实现，也可以单实现</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void a() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void c() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface  E&#123;</span><br><span class="line">    void e();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface F&#123;</span><br><span class="line">    void f();</span><br><span class="line">    void ff();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface G extends E,F&#123;      接口可以多继承</span><br><span class="line">    void g();</span><br><span class="line">    void gg();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class V implements G&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void e() &#123;   //以下都是对接口中的抽象方法进行重写</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void f() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void ff() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void g() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void gg() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h1><h2 id="成员区别："><a href="#成员区别：" class="headerlink" title="成员区别："></a>成员区别：</h2><ul><li><p>抽象类：</p><p>成员变量：可以变量，也可以常量</p><p>构造方法：有</p><p>成员方法：可以抽象，也可以非抽象</p></li><li><p>接口：</p><p>成员变量：只可以常量</p><p>成员方法：只可以抽象</p></li></ul><h2 id="关系区别："><a href="#关系区别：" class="headerlink" title="关系区别："></a>关系区别：</h2><p>​    1.类与类：继承，单继承</p><p>​    2.类与接口：实现，单实现，多实现</p><p>​    3.接口与接口：继承，单继承，多继承</p><h2 id="设计理念区别："><a href="#设计理念区别：" class="headerlink" title="设计理念区别："></a>设计理念区别：</h2><ul><li>抽象类 被继承体现的是：”is a”的关系。    抽象类中定义的是该继承体系的共性功能。</li></ul><ul><li>接口 被实现体现的是：”like a”的关系。    接口中定义的是该继承体系的扩展功能。</li></ul><p>注意：JDK1.8之后在接口中提供了用default修饰的方法，可以给出功能的具体实现，子类可以继承下去用，相当于间接实现了多继承</p><p>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest2 &#123;</span><br><span class="line">    //JDK1.8之后，接口中可以定义默认方法</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">     C c= new C();</span><br><span class="line">     A a=c;</span><br><span class="line">     a.test();</span><br><span class="line">     a.test2();</span><br><span class="line">     a.test3();</span><br><span class="line">     B b=c;</span><br><span class="line">     b.test22();</span><br><span class="line">     b.test333();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface A&#123;</span><br><span class="line">    void hehe();</span><br><span class="line">    public default void test()&#123;</span><br><span class="line">        System.out.println(&quot;JDK1.8之后接口中，可以定义默认方法，可以有方法的具体实现&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public default void test2() &#123;</span><br><span class="line">        System.out.println(&quot;JDK1.8之后接口中，可以定义默认方法，可以有方法的具体实现&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public default void test3() &#123;</span><br><span class="line">        System.out.println(&quot;JDK1.8之后接口中，可以定义默认方法，可以有方法的具体实现&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface B &#123;</span><br><span class="line">    void hehe();</span><br><span class="line"></span><br><span class="line">    public default void show() &#123;</span><br><span class="line">        System.out.println(&quot;JDK1.8之后接口中，可以定义默认方法，可以有方法的具体实现？？？&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public default void test22() &#123;</span><br><span class="line">        System.out.println(&quot;JDK1.8之后接口中，可以定义默认方法，可以有方法的具体实现？？？&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public default void test333() &#123;</span><br><span class="line">        System.out.println(&quot;JDK1.8之后接口中，可以定义默认方法，可以有方法的具体实现？？？&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C implements A,B&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void hehe() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void test22() &#123;</span><br><span class="line">    System.out.println(&quot;JDK1.8之后接口中，可以定义默认方法，可以有方法的具体实现？？？，但是被重写了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象【四】（final关键字、多态）</title>
      <link href="/2019/04/17/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%90%E5%9B%9B%E3%80%91%EF%BC%88final%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E5%A4%9A%E6%80%81%EF%BC%89/"/>
      <url>/2019/04/17/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%90%E5%9B%9B%E3%80%91%EF%BC%88final%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E5%A4%9A%E6%80%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><ul><li><p>为什么会有final：</p><p>​    由于继承中有一个方法重写的现象,而有时候我们不想让子类去重写父类的方法.这对这种情况java就给我们提供了一个关键字: final</p></li><li><p>final概述：</p><p>final关键字是最终的意思，可以修饰<strong>类</strong>，<strong>变量</strong>，<strong>成员方法</strong></p></li></ul><h1 id="final关键字修饰类-方法以及变量的特点"><a href="#final关键字修饰类-方法以及变量的特点" class="headerlink" title="final关键字修饰类,方法以及变量的特点"></a>final关键字修饰类,方法以及变量的特点</h1><p>final修饰特点：</p><ul><li>修饰类:    被修饰类不能被继承</li><li>修饰方法:    被修饰的方法不能被重写</li><li>修饰变量:    被修饰的变量不能被重新赋值,因为这个量其实是一个常量</li></ul><p>代码示例：</p><p>​    final修饰成员变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    public static final int A=10; //公共的静态常量</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //final 最终的，可以修饰类，变量，可以修饰成员方法</span><br><span class="line">        final int NUM=100; //自定义常量  常量的命名字母全部大写</span><br><span class="line">        System.out.println(A);</span><br><span class="line">        System.out.println(MyTest.A);</span><br><span class="line">        System.out.println(NUM);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">10</span><br><span class="line">100</span><br></pre></td></tr></table></figure><h2 id="final修饰类："><a href="#final修饰类：" class="headerlink" title="final修饰类："></a>final修饰类：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //final 修饰类，此类不能被继承</span><br><span class="line">        B b = new B();</span><br><span class="line">        b.show1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final class A&#123;</span><br><span class="line"></span><br><span class="line">    public void show1()&#123;</span><br><span class="line">        System.out.println(&quot;这是父类的成员方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A&#123;</span><br><span class="line">    public void show()&#123;</span><br><span class="line">        System.out.println(&quot;这是子类的成员方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码对类进行了final修饰，运行上述代码，会报错。</p><p>B类无法成功继承A类</p><h2 id="final修饰成员方法："><a href="#final修饰成员方法：" class="headerlink" title="final修饰成员方法："></a>final修饰成员方法：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //final 修饰方法，此方法不能被重写,子类可以原封不动的继承下去用，就是不能重写</span><br><span class="line"></span><br><span class="line">        new Zi().test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fu&#123;</span><br><span class="line"></span><br><span class="line">    public void show()&#123;</span><br><span class="line">        System.out.println(&quot;这是父类的show方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public final void test()&#123;</span><br><span class="line">        System.out.println(&quot;这是父类的final&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Zi extends Fu&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        super.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述代码可以看出，通过final关键字修饰了成员方法，执行上述代码会报错，test()无法覆盖。</p><p>可知，被final修饰过的成员方法不能被子类重写。</p><h1 id="final关键字修饰局部变量"><a href="#final关键字修饰局部变量" class="headerlink" title="final关键字修饰局部变量"></a>final关键字修饰局部变量</h1><ol><li>基本类型，是值不能被改变</li><li>引用类型，是地址值不能被改变</li></ol><h1 id="多态的概述及其代码体现"><a href="#多态的概述及其代码体现" class="headerlink" title="多态的概述及其代码体现"></a>多态的概述及其代码体现</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>某一个事物，在不同时刻表现出来的不同状态。</p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat c=new Cat();</span><br><span class="line">Animal a=new Cat();</span><br></pre></td></tr></table></figure><p>猫可以是猫的类型。猫 m = new 猫();<br>同时猫也是动物的一种，也可以把猫称为动物。动物 d = new 猫();</p><h2 id="多态前提"><a href="#多态前提" class="headerlink" title="多态前提"></a>多态前提</h2><ul><li>要有继承关系。</li><li>要有方法重写。 其实没有也是可以的，但是如果没有这个就没有意义。</li><li>要有父类引用指向子类对象。<code>父 f = new 子();</code></li></ul><p>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Animal an=new Cat();</span><br><span class="line">        an.sleep();</span><br><span class="line">        an.eat();</span><br><span class="line">        an.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animal&#123;</span><br><span class="line">    public void eat()&#123;</span><br><span class="line">        System.out.println(&quot;吃饭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sleep() &#123;</span><br><span class="line">        System.out.println(&quot;睡觉&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;父类中的show方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;猫爱吃鱼&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sleep() &#123;</span><br><span class="line">        System.out.println(&quot;猫爱白天睡觉&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码就是对多态的举例，运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">猫爱白天睡觉</span><br><span class="line">猫爱吃鱼</span><br><span class="line">父类中的show方法</span><br></pre></td></tr></table></figure><h1 id="多态中的成员访问特点"><a href="#多态中的成员访问特点" class="headerlink" title="多态中的成员访问特点"></a>多态中的成员访问特点</h1><p>多态中的成员访问特点</p><ul><li>成员变量，编译看左边，运行看左边。</li><li>构造方法，创建子类对象的时候，会访问父类的构造方法，对父类的数据进行初始化。</li><li>成员方法，编译看左边，运行看右边。</li><li>静态方法，编译看左边，运行看左边(静态和类相关，算不上重写，所以，访问还是左边的)。</li></ul><h1 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h1><p>多态的好处</p><ul><li>提高了代码的维护性(继承保证)</li><li>提高了代码的扩展性(由多态保证)</li></ul><h1 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h1><p>通过多态的弊端引出问题：</p><p>不能使用子类特有的功能</p><ul><li><p>解决方法：</p><p>把父类的引用强制转换为子类的引用。(向下转型)</p></li></ul><h1 id="向上转型和向下转型"><a href="#向上转型和向下转型" class="headerlink" title="向上转型和向下转型"></a>向上转型和向下转型</h1><h2 id="1-向上转型（upcasting）"><a href="#1-向上转型（upcasting）" class="headerlink" title="1.向上转型（upcasting）"></a>1.向上转型（upcasting）</h2><p>​    子—-&gt;父    自动类型提升</p><h2 id="2-向下转型（downcasting）"><a href="#2-向下转型（downcasting）" class="headerlink" title="2.向下转型（downcasting）"></a>2.向下转型（downcasting）</h2><p>​    父—-&gt;子   强制类型转换</p><ul><li>注意：无论是向上转型还是向下转型，两个类之间必须要有继承关系</li></ul><p>代码示例：</p><p>父类： 动物类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line">    public void eat()&#123;</span><br><span class="line">        System.out.println(&quot;动物在吃！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类1：猫类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Cat extends Animal&#123;</span><br><span class="line">    public void eat()&#123;</span><br><span class="line">        System.out.println(&quot;猫吃鱼！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void move()&#123;</span><br><span class="line">    System.out.println(&quot;猫走猫步&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类2：狗类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Dog extends Animal &#123;</span><br><span class="line">    public void eat()&#123;</span><br><span class="line">        System.out.println(&quot;狗啃骨头&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类1：没转型，正常调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Animal a1 = new Animal();</span><br><span class="line">        a1.eat();</span><br><span class="line"></span><br><span class="line">        Cat c1 = new Cat();</span><br><span class="line">        c1.eat();</span><br><span class="line">        </span><br><span class="line">        Dog d1 = new Dog();</span><br><span class="line">        d1.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class Test2 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">        //向上转型又被称作：自动类型转换</span><br><span class="line">        </span><br><span class="line">        //向上转型，子类转为父类</span><br><span class="line">        //父类型的引用指向子类型对象</span><br><span class="line">        //程序分两个阶段：编译阶段，运行阶段</span><br><span class="line">        //程序编译阶段只知道a1是一个Animal类</span><br><span class="line">        //程序运行的时候堆中的实际对象是Cat类型</span><br><span class="line">        Animal a1 = new Cat();</span><br><span class="line"></span><br><span class="line">        //程序在编译阶段a1被看做Animal类型</span><br><span class="line">        //所以程序在编一阶段a1引用绑定的是Animal类中的eat方法（静态绑定）</span><br><span class="line">        a1.eat();  //猫吃鱼！</span><br><span class="line">        </span><br><span class="line">        ===========================================================</span><br><span class="line">         //向下转型，强制类型转换</span><br><span class="line">         Animal a2 = new Cat();</span><br><span class="line">        //要执行猫类的特有方法,怎么做？</span><br><span class="line">        Cat c1 = (Cat) a2;</span><br><span class="line">        c1.move(); </span><br><span class="line">        ===========================================================</span><br><span class="line">        //抛出异常</span><br><span class="line">        //做强制类型转换是有风险的</span><br><span class="line">        Animal a3 = new Dog();  //向上转型，底层是Dog类</span><br><span class="line">        Cat c2 = (Cat) a3;   //所以就不能强转成Cat类，因为之间没继承</span><br><span class="line">         //报错：ClassCastException</span><br><span class="line">         </span><br><span class="line">         //为了避免ClassCastException，引入了instanceof</span><br><span class="line">         /*</span><br><span class="line">         * 用法：</span><br><span class="line">             1.instanceof作为运算符返回的结果是boolean类型</span><br><span class="line">             2.(引用 instanceof 类型)-----&gt;true/false</span><br><span class="line">             </span><br><span class="line">             例如：(a instanceof Cat) 如果是true，则a指向堆中的对象是Cat类型</span><br><span class="line">         ============================================================</span><br><span class="line">         Animal a3 = new Dog();</span><br><span class="line">         if(a3 instanceof Cat)&#123;</span><br><span class="line">             Cat c2 =(Cat) a3;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="静态绑定和动态绑定"><a href="#静态绑定和动态绑定" class="headerlink" title="静态绑定和动态绑定"></a>静态绑定和动态绑定</h1><p>静态绑定：编译阶段a1引用绑定的是Animal类中的eat()方法。</p><p>动态绑定：但是运行阶段，堆中的对象实际上是Cat类型，而Cat已经重写了eat方法，所以程序在运行阶段对象的绑定的方法时Cat中的eat方法</p><h1 id="instance可以判断类型"><a href="#instance可以判断类型" class="headerlink" title="instance可以判断类型"></a>instance可以判断类型</h1><ul><li><p>用法：</p><pre><code>1.instanceof作为运算符返回的结果是boolean类型2.(引用 instanceof 类型)-----&gt;true/false例如：(a instanceof Cat) 如果是true，则a指向堆中的对象是Cat类型</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象【三】(代码块、继承、构造方法、方法重写)</title>
      <link href="/2019/04/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%90%E4%B8%89%E3%80%91(%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E3%80%81%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99)/"/>
      <url>/2019/04/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%90%E4%B8%89%E3%80%91(%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E3%80%81%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99)/</url>
      
        <content type="html"><![CDATA[<h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ul><li><p>代码块概述</p><p>在Java中，使用{}括起来的代码被称为代码块。</p></li><li><p>代码块分类<br>根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块(多线程讲解)。</p></li><li><p>常见代码块的应用：</p><p>1.局部代码块，在方法中出现；限定变量生命周期，及早释放，提高内存利用率</p><p>2.构造代码块，在类中方法外出现；在创建对象时执行，优先于构造方法执行，每创建一个对象都会执行</p><p>3.静态代码块，在类中方法外出现，加了static修饰，用于给类进行初始化，在加载的时候就执行，并且只执行一次。静态代码块里面只能访问静态变量</p></li></ul><p>  看程序写结果，语句后面的数字为执行顺序</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Student &#123;</span><br><span class="line">static &#123;</span><br><span class="line">System.out.println(&quot;Student 静态代码块&quot;); //3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;Student 构造代码块&quot;); //4 6</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Student() &#123;</span><br><span class="line">System.out.println(&quot;Student 构造方法&quot;); //5 7</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class StudentDemo &#123;</span><br><span class="line">static &#123;</span><br><span class="line">System.out.println(&quot;StudentDemo的静态代码块&quot;);//1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(&quot;我是main方法&quot;);//2</span><br><span class="line"></span><br><span class="line">Student s1 = new Student();</span><br><span class="line">Student s2 = new Student();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ul><li><p>继承概述<br>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。</p></li><li><p>继承格式</p><ol><li>通过<code>extends</code>关键字可以实现类与类的继承</li><li><code>class 子类名 extends 父类名 {}</code></li><li>单独的这个类称为父类，基类或者超类；这多个类可以称为子类或者派生类。</li></ol></li></ul><h2 id="继承的好处和弊端"><a href="#继承的好处和弊端" class="headerlink" title="继承的好处和弊端"></a>继承的好处和弊端</h2><p>​    案例：</p><p>父类<code>Person</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line"></span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃饭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sleep() &#123;</span><br><span class="line">        System.out.println(&quot;睡觉&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类<code>Student</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Student extends Person&#123;</span><br><span class="line"></span><br><span class="line">    public void talkLove()&#123;</span><br><span class="line">        System.out.println(&quot;谈恋爱&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类<code>Teacher</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Teacher extends Person&#123;</span><br><span class="line"></span><br><span class="line">    public void teache()&#123;</span><br><span class="line">        System.out.println(&quot;教书&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码可以看出:</p><ul><li>Student和Teacher类继承了Person类的成员变量和成员方法，因为Teacher和Student作为人都会具有年龄和姓名两个属性，而且具有吃饭和睡觉的功能.</li><li>因为我们将这些子类所具有的相同功能都抽取到一个类中作为父类，所以Teacher和Student类不需要再写这些代码，只需要从父类那里继承就行，并且继承后可以在类中加入自己独特的功能代码，比如Teacher会教书，Student会谈恋爱。</li><li>继承完成后我们就可以利用<code>Studnet</code>和<code>Teacher</code>来创建各自的对象</li></ul><p>测试类<code>MyTest</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student student = new Student();</span><br><span class="line">        student.name=&quot;张三&quot;;      //调用了继承了父类的成员变量</span><br><span class="line">        student.age=19;</span><br><span class="line">        System.out.println(student.name+&quot;===&quot;+student.age);</span><br><span class="line">        student.sleep();          //调用了继承了父类的成员方法</span><br><span class="line">        student.eat();</span><br><span class="line">        student.talkLove();       //调用自己特有的方法</span><br><span class="line">        System.out.println(&quot;-----------------&quot;);</span><br><span class="line">        Teacher teacher = new Teacher();</span><br><span class="line">        teacher.name=&quot;沈某某&quot;;</span><br><span class="line">        teacher.age=10;</span><br><span class="line">        System.out.println(teacher.name+&quot;===&quot;+teacher.age);</span><br><span class="line">        teacher.sleep();</span><br><span class="line">        teacher.eat();</span><br><span class="line">        teacher.teache();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承的好处："><a href="#继承的好处：" class="headerlink" title="继承的好处："></a>继承的好处：</h3><ol><li>提高了代码的复用性</li><li>提高了代码的维护性（比如要想修改<code>吃饭</code>为<code>吃米饭</code>便可直接在父类中进行修改，而不用在两个子类中分别修改，提升了代码的维护性）</li><li>让类与类之间产生了关系，是多态的前提</li></ol><h3 id="继承的弊端："><a href="#继承的弊端：" class="headerlink" title="继承的弊端："></a>继承的弊端：</h3><p>类的耦合性增强了。（可能改变了父类中的一些成员，导致它的子类中的东西也会改变，这也是耦合的缺点）</p><ul><li>开发的原则：高内聚，低耦合。</li><li>耦合：类与类的关系</li><li>内聚：就是自己完成某件事情的能力</li></ul><h2 id="类的继承特点"><a href="#类的继承特点" class="headerlink" title="类的继承特点"></a>类的继承特点</h2><p>Java中类的继承特点：</p><ul><li>Java <strong>只支持单继承</strong>，<strong>不支持多继承</strong>，有些语言是支持多继承，格式：extends 类1,类2,…</li><li>Java支持多层继承(继承体系)</li><li>Object是所有类的顶层父类，所有类都是直接，或间接继承自他</li></ul><h2 id="继承的注意事项"><a href="#继承的注意事项" class="headerlink" title="继承的注意事项"></a>继承的注意事项</h2><ul><li><p>继承的注意事项：</p><p>子类只能继承父类所有非私有的成员(成员方法和成员变量)</p><p>子类不能继承父类的构造方法，但是可以通过super(待会儿讲)关键字去访问父类构造方法。</p><p>不要为了部分功能而去继承</p></li><li><p>什么时候使用继承：</p><p>如果有两个类A,B。只有他们符合A是B的一种，或者B是A的一种，就可以考虑使用继承。</p></li></ul><h2 id="继承中成员变量的关系"><a href="#继承中成员变量的关系" class="headerlink" title="继承中成员变量的关系"></a>继承中成员变量的关系</h2><ul><li><p>在使用继承时可能会存在下面两种情况：</p><p>1.子类中的成员变量和父类中的成员变量名称不一样</p><p>2.子类中的成员变量和父类中的成员变量名称一样</p></li></ul><ul><li>上述问题如何解决？这就涉及到之前讲过的变量查找顺序遵循的就近原则，是对之前的就近原则的拓展</li></ul><p>在子类中访问一个变量的查找顺序(<strong>就近原则</strong>)：</p><p>​        1.在子类的方法的局部范围找,有就使用</p><p>​        2.在子类的成员范围找,有就使用</p><p>​        3.在父类的成员范围找,有就使用</p><p>​        4.如果还找不到,就报错</p><p>代码示例：<br>执行下面的测试类（子类中的成员方法形参、成员变量以及父类的成员变量名一样）后，如果我想输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">200</span><br><span class="line">100</span><br></pre></td></tr></table></figure><p>程序中的成员方法应该如何定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        B b = new B();</span><br><span class="line">        int num=1;</span><br><span class="line">        b.show(num);</span><br><span class="line">        //变量的访问原则：遵循就近原则，先在局部找这个变量，找到就使用，如果局部没找到，去本类的成员位置找，找到就使用</span><br><span class="line">        //如果本类的成员位置没找到，去父类的成员位置找，找到就使用。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A&#123;</span><br><span class="line">    int num=100;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A&#123;</span><br><span class="line">    int num=200;</span><br><span class="line">    public void show(int num)&#123;</span><br><span class="line">        //就近访问原则</span><br><span class="line">        System.out.println(num); </span><br><span class="line">        System.out.println(this.num);</span><br><span class="line">        //System.out.println(new A().num);  //涉及到匿名变量</span><br><span class="line">        System.out.println(super.num);      //引入super关键字</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="this和super的区别和应用"><a href="#this和super的区别和应用" class="headerlink" title="this和super的区别和应用"></a>this和super的区别和应用</h1><ul><li><p><code>this</code>和<code>super</code>的区别：<br><code>this</code> 代表的是本类对象的引用，谁调用成员方法<code>this</code>就代表谁<br><code>super</code>代表的是父类存储空间的标识(可以理解成父类的引用,可以操作父类的成员)</p></li><li><p>this和super的使用：</p><ul><li><p>调用成员变量：<br>1.<code>this.成员变量</code> 调用本类的成员变量</p><p>2.<code>super.成员变量</code> 调用父类的成员变量</p></li><li><p>调用构造方法：<br>1.<code>this(...)</code>    调用本类的构造方法</p><p>2.<code>super(...)</code>    调用父类的构造方法</p></li><li><p>调用成员方法：<br>1.<code>this.成员方法</code> 调用本类的成员方法<br>2.<code>super.成员方法</code> 调用父类的成员方法</p></li></ul></li></ul><p>代码演示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        B b = new B();                      //this()   访问本类的空参构造</span><br><span class="line">        b.show(1);                          // super()  访问父类的空参构造</span><br><span class="line">        b.hehe();</span><br><span class="line">        System.out.println(&quot;------------&quot;);</span><br><span class="line">        b.test();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">    int a = 200;</span><br><span class="line"></span><br><span class="line">    public void hehe() &#123;</span><br><span class="line">        System.out.println(&quot;这是父类的一个方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">    int a = 100;</span><br><span class="line"></span><br><span class="line">    public void show(int a) &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(this.a);</span><br><span class="line">        System.out.println(super.a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test2() &#123;</span><br><span class="line">        System.out.println(&quot;这是子类test2方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test() &#123;</span><br><span class="line">        this.test2();</span><br><span class="line">        this.hehe();//本类对象调用父类的方法</span><br><span class="line">        super.hehe();//使用父类的空间标识去调用父类的方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上述讲解可知该代码演示最终的输出结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">100</span><br><span class="line">200</span><br><span class="line">这是父类的一个方法</span><br><span class="line">------------</span><br><span class="line">这是子类test2方法</span><br><span class="line">这是父类的一个方法</span><br><span class="line">这是父类的一个方法</span><br></pre></td></tr></table></figure><h1 id="继承中构造方法的关系"><a href="#继承中构造方法的关系" class="headerlink" title="继承中构造方法的关系"></a>继承中构造方法的关系</h1><p>子类中所有的构造方法默认都会访问父类中空参数的构造方法（来实现对父类的初始化）</p><p>原因：因为子类会继承父类中的数据，可能还会使用父类的数据，所以，子类初始化之前，一定要先完成父类数据的初始化。</p><p>其实：<br>每一个构造方法的第一条语句默认都是：super()，只要在写构造方法时系统就会默认在第一条语句之前写上这条语句，但是不会显示，所以我们可以写也可以不写，不会影响对父类构造的初始化，注意Object没有父类。</p><p>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Son son = new Son(10);</span><br><span class="line">        System.out.println(son.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Father&#123;</span><br><span class="line">    int num=1000;</span><br><span class="line">    public Father() &#123;</span><br><span class="line">        super();</span><br><span class="line">        System.out.println(&quot;这是父类的空参构造&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Father&#123;</span><br><span class="line">    int b=1;</span><br><span class="line">    public Son() &#123;</span><br><span class="line">        super();</span><br><span class="line">        System.out.println(&quot;这是子类的空参&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Son(int b) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.b = b;</span><br><span class="line">        System.out.println(&quot;子类有参构造执行了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照上述讲解可知上述代码最终输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是父类的空参构造</span><br><span class="line">子类有参构造执行了</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h1 id="继承中构造方法的案例演示及注意事项"><a href="#继承中构造方法的案例演示及注意事项" class="headerlink" title="继承中构造方法的案例演示及注意事项"></a>继承中构造方法的案例演示及注意事项</h1><ul><li><p>父类没有无参构造方法,子类怎么办?</p><p>在父类中添加一个无参的构造方法</p><p>子类通过super去显示调用父类其他的带参的构造方法</p><p>子类通过this去调用本类的其他构造方法，本类其他构造也必须首先访问了父类构造</p></li><li><p>注意事项：<br><code>super(…)</code>或者<code>this(…)</code>必须出现在第一条语句上，要在执行构造方法中的业务逻辑之前完成对父类构造方法的调用或者对本类其他构造方法的调用</p></li></ul><p>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ////假如我父类里面没有提供空参构造怎么办？</span><br><span class="line">        ////1.那子类可以去调父类有参构造</span><br><span class="line">        ////2.先用this(参数)本类的有参构造，然后你调用的那个构造又去调用父类的有参构造</span><br><span class="line">        //System.out.println(zi.num);</span><br><span class="line">        Zi zi = new Zi();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fu&#123;</span><br><span class="line">    int num=10;</span><br><span class="line"></span><br><span class="line">    public Fu(int num) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.num = num;</span><br><span class="line">        System.out.println(&quot;父类的有参构造执行了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Zi extends Fu&#123;</span><br><span class="line">    int num=100;</span><br><span class="line">    public Zi() &#123;</span><br><span class="line">        super(10);</span><br><span class="line">       // this(10000);</span><br><span class="line">        System.out.println(&quot;子类的空参构造执行了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Zi(int num) &#123;</span><br><span class="line">        super(num);</span><br><span class="line">        System.out.println(&quot;子类的有参构造执行了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上述知识点讲解可知上述代码最终输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类的有参构造执行了</span><br><span class="line">子类的空参构造执行了</span><br></pre></td></tr></table></figure><h1 id="继承中的面试题"><a href="#继承中的面试题" class="headerlink" title="继承中的面试题"></a>继承中的面试题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">A:案例演示</span><br><span class="line">看程序写结果1</span><br><span class="line">class Fu&#123;</span><br><span class="line">public int num = 10;</span><br><span class="line">public Fu()&#123;</span><br><span class="line">System.out.println(&quot;fu&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Zi extends Fu&#123;</span><br><span class="line">public int num = 20;</span><br><span class="line">public Zi()&#123;</span><br><span class="line">System.out.println(&quot;zi&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void show()&#123;</span><br><span class="line">int num = 30;</span><br><span class="line">System.out.println(num);//30</span><br><span class="line">System.out.println(this.num);//20</span><br><span class="line">System.out.println(super.num);//10</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Zi z = new Zi();</span><br><span class="line">z.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B:案例演示</span><br><span class="line">看程序写结果2</span><br><span class="line">class Fu &#123;</span><br><span class="line">static &#123;</span><br><span class="line">System.out.println(&quot;静态代码块Fu&quot;); //1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;构造代码块Fu&quot;); //3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Fu() &#123;</span><br><span class="line">System.out.println(&quot;构造方法Fu&quot;); //4</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Zi extends Fu &#123;</span><br><span class="line">static &#123;</span><br><span class="line">System.out.println(&quot;静态代码块Zi&quot;); //2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;构造代码块Zi&quot;); //5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Zi() &#123;</span><br><span class="line">System.out.println(&quot;构造方法Zi&quot;); //6</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Zi z = new Zi(); 请执行结果。</span><br></pre></td></tr></table></figure><p>A案例的输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fu</span><br><span class="line">zi</span><br><span class="line">30</span><br><span class="line">20</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>B案例的输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">静态代码块Fu</span><br><span class="line">静态代码块Zi</span><br><span class="line">构造代码块Fu</span><br><span class="line">构造方法Fu</span><br><span class="line">构造代码块Zi</span><br><span class="line">构造方法Zi</span><br></pre></td></tr></table></figure><h1 id="继承中成员方法关系"><a href="#继承中成员方法关系" class="headerlink" title="继承中成员方法关系"></a>继承中成员方法关系</h1><p>在使用继承时可能会出现下面两种情况：</p><ul><li>当子类的方法名和父类的方法名不一样的时候</li><li>当子类的方法名和父类的方法名一样的时候</li></ul><p>通过子类调用方法的查找顺序:</p><ol><li>先查找子类中有没有该方法,如果有就使用</li><li>再看父类中有没有该方法,有就使用</li><li>如果没有就报错</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">     public static void main(String[] args) &#123;</span><br><span class="line">        Zi zi = new Zi();</span><br><span class="line">        zi.show();</span><br><span class="line">        zi.test();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fu &#123;</span><br><span class="line">    int num2=100;</span><br><span class="line">    public void show()&#123;</span><br><span class="line">        System.out.println(&quot;我是父类的show方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Zi extends Fu&#123;</span><br><span class="line">    int num=200;</span><br><span class="line"></span><br><span class="line">    public void test()&#123;</span><br><span class="line">        System.out.println(&quot;我是子类的test方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;我是子类的show方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h1><ul><li><p>什么是方法重写：</p><p>子类中出现了和父类中一模一样的方法声明(方法名,参数列表,返回值类型)，也被称为方法覆盖，方法复写。</p></li><li><p>方法重写的应用：</p><p>如果说子类对父类的方法实现不满意，那么子类就可以覆盖他，或者说，子类想要对父类的方法的实现功能进行扩展，也可以使用方法重写的这种机制</p></li></ul><h1 id="方法重写的注意事项"><a href="#方法重写的注意事项" class="headerlink" title="方法重写的注意事项"></a>方法重写的注意事项</h1><ul><li><p>方法重写注意事项：</p><p>1.父类中私有方法不能被重写，因为父类私有方法子类根本就无法继承<br>2.子类重写父类方法时，访问权限不能更低，最好就一致<br>3.父类静态方法，子类也必须通过静态方法进行重写 其实这个算不上方法重写，但是现象确实如此</p><p>4.子类重写父类方法的时候，最好声明一模一样。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象【二】(this关键字、构造方法、static关键字、静态变量和成员变量的区别、Math类的随机数功能)</title>
      <link href="/2019/04/14/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%90%E4%BA%8C%E3%80%91(this%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81Math%E7%B1%BB%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%8A%9F%E8%83%BD)/"/>
      <url>/2019/04/14/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%90%E4%BA%8C%E3%80%91(this%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81Math%E7%B1%BB%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%8A%9F%E8%83%BD)/</url>
      
        <content type="html"><![CDATA[<h1 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h1><p>当我们的局部变量和成员变量相同的时候,如果我们不使用this关键字,那么会导致一个问题:就是局部变量隐藏了成员变量的问题。</p><p><strong>this关键字代表当前类的引用</strong>，简单地说就是代表当前类的一个对象，谁调用这个方法，这个方法的内部的this就代表谁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class TestThis &#123;</span><br><span class="line"></span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">            A a = new A();</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            int num=10; //定义在栈内存中</span><br><span class="line">            a.show(num,a);</span><br><span class="line">            System.out.println(num); //10</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class A&#123;</span><br><span class="line">        int num=100;  //定义在堆内存中</span><br><span class="line">        public void show(int num, A a)&#123;</span><br><span class="line">            System.out.println(this); //本类引用</span><br><span class="line">            System.out.println(num); //10</span><br><span class="line">            System.out.println(a.num); //100</span><br><span class="line">            System.out.println(this.num);  //100</span><br><span class="line">            System.out.println(a==this);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">org.westos.homework0406.A@1540e19d</span><br><span class="line">org.westos.homework0406.A@1540e19d</span><br><span class="line">10</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line">true</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><ul><li><p>作用</p><p>创建对象时为对象中的成员进行初始化</p></li><li><p>特点</p><p>方法名与类名相同<br>么有具体的返回值类型<br>方法声明不写返回值类型，void也不用</p></li><li><p>注意事项</p><p>如果没有自定义构造方法，系统会自动提供一个空参构造；若给出了有参构造，系统将不再提供空参构造，如果还需要空参构造，必须手动给出</p></li><li><p>给成员变量赋值的两种方式<br>a:setXxx()方法</p><p>b:构造方法</p></li></ul><p>案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Student() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Student(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void sleep() &#123;</span><br><span class="line">        System.out.println(&quot;睡觉&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃饭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h1><p>​    static 静态的 可以修饰成员变量，和成员方法<br>​    被static所修饰的成员变量，是一个共享变量，被类的所有对象所共享<br>​    被静态所修饰的成员，是随时类的加载而加载（随着 .class文件进内存，静态的东西就会加载）</p><p>​    优先于对象而存在</p><p>案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    public String name;</span><br><span class="line"></span><br><span class="line">    public static String country = &quot;中国&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //想让中国，让这个三个对象共享</span><br><span class="line">        Person person = new Person();</span><br><span class="line">        person.name=&quot;张三&quot;;</span><br><span class="line">        person.country=&quot;美国&quot;;</span><br><span class="line">        System.out.println(&quot;---------------&quot;);</span><br><span class="line">        Person person2 = new Person();</span><br><span class="line">        person2.name = &quot;李四&quot;;</span><br><span class="line">        person2.country = &quot;新加坡&quot;;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;---------------&quot;);</span><br><span class="line">        Person person3 = new Person();</span><br><span class="line">        person3.name = &quot;王五&quot;;</span><br><span class="line"></span><br><span class="line">        person3.country = &quot;英国&quot;;</span><br><span class="line"></span><br><span class="line">        System.out.println(person.name+&quot;----&quot;+person.country); //张三---英国</span><br><span class="line">        System.out.println(person2.name + &quot;----&quot; + person2.country); //李四---英国</span><br><span class="line">        System.out.println(person3.name + &quot;----&quot; + person3.country); //王五---英国</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>static关键字的特点</p><p>随着类的加载而加载<br>可以通过类名调用<br>优先于对象存在<br>被类的所有对象共享</p></li><li><p>注意事项：</p><p>静态方法中不能使用this关键字，this表示本类的引用，即一个对象，而静态是虽类的加载而加载的，静态比对象先存在</p><p>静态方法只能访问静态成员变量和静态成员方法（静态只能访问静态）</p></li></ul><h1 id="静态变量和成员变量的区别"><a href="#静态变量和成员变量的区别" class="headerlink" title="静态变量和成员变量的区别"></a>静态变量和成员变量的区别</h1><ul><li><p>在内存中位置不同</p><p>静态变量存储在方法区的静态区<br>成员变量存储在堆内存</p></li><li><p>所属不同</p><p>静态变量属于类（类变量）<br>成员变量属于对象（实例变量/对象变量）</p></li><li><p>生命周期不同</p><p>静态变量随类的加载而加载，随类的消失而消失<br>成员变量随对象的创建而存在，随对象的消失而消失</p></li><li><p>调用方式不同</p><p>静态变量既可以通过类名调用，也可以通过对象调用</p><p>成员变量只能通过对象调用</p></li></ul><h1 id="Math类的随机数功能"><a href="#Math类的随机数功能" class="headerlink" title="Math类的随机数功能"></a>Math类的随机数功能</h1><ul><li>Math类包含用于执行基本数学运算的方法，由于Math类在java.lang包下，所以不需要导包。Math类没有构造方法，因为它的成员全部是静态的。</li></ul><ul><li><p>获取随机数的方法</p><p>public static double random():返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。若要获取一个1-100之间的随机数，可int number = (int)(Math.random()*100)+1;</p></li></ul><p>案例：猜数字小游戏(数据在1-100之间)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class RandomGame &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;请输入一个数1~100&quot;);</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        int answer = (int) (Math.random()*100+1);</span><br><span class="line">        int index = 1;</span><br><span class="line">        while (index&lt;=10)&#123;</span><br><span class="line">            int num = scanner.nextInt();</span><br><span class="line">            if(num&gt;answer)&#123;</span><br><span class="line">                System.out.println(&quot;猜大了&quot;);</span><br><span class="line">                System.out.println(&quot;你还剩&quot;+(610-index)+&quot;次机会&quot;);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;else if(num&lt;answer)&#123;</span><br><span class="line">                System.out.println(&quot;猜小了&quot;);</span><br><span class="line">                System.out.println(&quot;你还剩&quot;+(10-index)+&quot;次机会&quot;);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                System.out.println(&quot;恭喜你，猜对了&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象【一】（类、成员变量、局部变量、匿名对象、封装、private关键字）</title>
      <link href="/2019/04/14/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%90%E4%B8%80%E3%80%91%EF%BC%88%E7%B1%BB%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%EF%BC%89/"/>
      <url>/2019/04/14/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%90%E4%B8%80%E3%80%91%EF%BC%88%E7%B1%BB%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象概述"><a href="#面向对象概述" class="headerlink" title="面向对象概述"></a>面向对象概述</h1><ul><li><p>面向过程思想概述<br>一步一步去实现，而具体的每一步都需要我们去实现和操作。这些步骤相互调用和协作，完成我们的需求。在上面的每一个具体步骤中我们都是参与者，并且需要面对具体的每一个步骤和过程，这就是面向过程最直接的体现。<br>那么什么是面向过程开发呢? 面向过程开发，其实就是面向着具体的每一个步骤和过程，把每一个步骤和过程完成，然后由这些功能方法相互调用，完成需求。代表语言：C语言</p></li><li><p>面向对象思想概述<br>当需求单一，或者简单时，我们一步一步去操作没问题，并且效率也挺高。可随着需求的更改，功能的增多，发现需要面对每一个步骤很麻烦了。这时就开始思索，能不能把这些步骤和功能在进行封装，封装时根据不同的功能，进行不同的封装，功能类似的封装在一起。这样结构就清晰了很多。用的时候，找到对应的类就可以了。这就是面向对象的思想。</p></li><li><p>面向对象思想特点<br>a:是一种更符合我们思想习惯的思想<br>b:可以将复杂的事情简单化<br>c:将我们从执行者变成了指挥者角色发生了转换</p></li><li><p>举例</p></li></ul><pre><code>洗衣服：换下脏衣服—找盆接水—泡一泡—手搓-----漂清----晾干面向对象：找个对象（洗衣服）、全自动洗衣机（一键洗衣（调用方法））</code></pre><ul><li>面向对象特征</li></ul><pre><code>封装(encapsulation)继承(inheritance)多态(polymorphism)</code></pre><ul><li><p>面向对象开发</p><p>​    就是不断的创建对象，使用对象，指挥对象做事情</p></li></ul><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类就是一组相关属性和功能的集合，对象是该类事物的实例化，例如：学生的实例化之一为班长，班长就是学生类的一个对象。</p><ul><li><p>成员变量和成员方法</p><p>定义类其实就是定义类的成员(成员变量和成员方法)</p></li><li><p>类的使用<br>A:文件名问题<br>在一个java文件中写两个类：一个基本的类，一个测试类。<br>建议：文件名称和测试类名称一致。<br>B:如何使用呢?<br>创建对象使用。<br>C:如何创建对象呢?<br>格式：类名 对象名 = new 类名();<br>D:如何使用成员变量呢?<br>格式：对象名.变量名<br>E:如何使用成员方法呢?<br>格式：对象名.方法名(…)</p></li><li><p>案例：</p></li></ul><p>​       定义一个手机类并使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//定义类</span><br><span class="line">public class Phone &#123;</span><br><span class="line">    //成员变量：定义在类中，方法外</span><br><span class="line">    String name = &quot;小米&quot;;</span><br><span class="line">    double price = 1000;</span><br><span class="line">    String color = &quot;白色&quot;;</span><br><span class="line"></span><br><span class="line">    //成员方法</span><br><span class="line">    public void call(String name) &#123;</span><br><span class="line">        System.out.println(&quot;给&quot; + name + &quot;打电话&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sendMsg(String name, String content) &#123;</span><br><span class="line">        System.out.println(&quot;给&quot; + name + &quot;发短信，内容是&quot; + content);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//使用该类</span><br><span class="line">public class TestPhone &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">     //类是一个抽象的概念，你无法直接使用，要使用类中的属性功能，必须创建该类对象</span><br><span class="line">        Phone phone=new Phone();</span><br><span class="line">        //获取属性 对象名.属性名</span><br><span class="line">        String name=phone.name;</span><br><span class="line">        double price = phone.price;</span><br><span class="line">        String color = phone.color;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(price);</span><br><span class="line">        System.out.println(color);</span><br><span class="line">        //使用功能：对象名.方法名()</span><br><span class="line"></span><br><span class="line">        phone.call(&quot;张三&quot;);</span><br><span class="line">        phone.sendMsg(&quot;张三&quot;,&quot;生日快乐&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h1><ul><li><p>在类中的位置不同</p><p>成员变量：定义在类中方法外</p><p>局部变量：定义在方法中或方法声明上（形参）</p></li><li><p>在内存位置不同</p><p>成员变量：在堆内存中</p><p>局部变量：在栈内存中</p></li><li><p>生命周期不同</p><p>成员变量：随对象的创建而存在，随对象的消失而消失</p><p>局部变量：随方法的调用而存在，随方法的弹栈而消失</p></li><li><p>初始化值不同</p><p>成员变量：有默认初始化值</p><p>局部变量：无默认初始化值，必须赋值才能使用</p></li><li><p>注意事项：局部变量名称可以和成员变量名称一样，在方法中使用的时候，采用的是就近原则</p></li></ul><h1 id="方法的形式参数是类名的时候如何调用"><a href="#方法的形式参数是类名的时候如何调用" class="headerlink" title="方法的形式参数是类名的时候如何调用"></a>方法的形式参数是类名的时候如何调用</h1><ul><li>Java中参数传递问题<br>形式参数<br>基本类型（四类八种）：形式参数的改变不影响实际参数<br>引用类型：形式参数的改变直接影响实际参数</li><li>方法的参数是类名<br>如果一个方法的形式参数是一个类类型(引用类型)，这里其实需要的是该类的对象。</li></ul><h1 id="匿名对象的概述和应用"><a href="#匿名对象的概述和应用" class="headerlink" title="匿名对象的概述和应用"></a>匿名对象的概述和应用</h1><ul><li>匿名对象就是没有名字的对象</li><li>应用场景：对象的方法仅使用一次，也可作实际参数传递</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        //匿名对象调用方法</span><br><span class="line">        new Teacher().show(); //每new一次就是一个新的对象</span><br><span class="line">        new Teacher().show2();</span><br><span class="line">        new Teacher().show();</span><br><span class="line">        new Teacher().show();</span><br><span class="line">        //匿名对象调用成员变量</span><br><span class="line">        int num = new Teacher().num;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        //如果你以后看到一个方法的形参，要一个 类 类型，那么你就传一个该类对象</span><br><span class="line">        cat.show(cat, 19);</span><br><span class="line">        System.out.println(cat.num);</span><br><span class="line">        System.out.println(&quot;---------------------&quot;);</span><br><span class="line">        //匿名对象作为参数传递</span><br><span class="line">        //匿名对象可以作为参数传递</span><br><span class="line">        cat.show(new Cat(), 20);</span><br><span class="line">        System.out.println(cat.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Cat &#123;</span><br><span class="line">    int num = 100;</span><br><span class="line"></span><br><span class="line">    public void show(Cat cat, int num) &#123;</span><br><span class="line">        cat.num = num;</span><br><span class="line">        System.out.println(cat.num);//</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">19</span><br><span class="line">19</span><br><span class="line">---------------------</span><br><span class="line">20</span><br><span class="line">19</span><br></pre></td></tr></table></figure><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><ul><li>封装是指隐藏对象的属性和实现细节，仅对外提供公共访问方式</li><li>好处<ul><li>隐藏实现细节，提供公共的访问方式</li><li>提高了代码的复用性</li><li>提高安全性</li></ul></li><li>原则：将不需要对外提供的内容都隐藏起来，提供公共方法对其访问。</li></ul><h1 id="private关键字"><a href="#private关键字" class="headerlink" title="private关键字"></a>private关键字</h1><p>private是一个权限修饰符，可以修饰成员变量和成员方法，被其修饰只能在本类中被访问,提供get和set方法以供外界访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Student() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Student(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void sleep() &#123;</span><br><span class="line">        System.out.println(&quot;睡觉&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃饭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestStudent &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student student = new Student();</span><br><span class="line">        student.setName(&quot;张三&quot;);</span><br><span class="line">        student.setAge(20);</span><br><span class="line">        String name = student.getName();</span><br><span class="line">        int age = student.getAge();</span><br><span class="line">        System.out.println(&quot;姓名：&quot; + name + &quot;=== 年龄&quot; + age);</span><br><span class="line">        student.eat();</span><br><span class="line">        student.sleep();</span><br><span class="line">        System.out.println(&quot;-------------------&quot;);</span><br><span class="line">        Student student1 = new Student();</span><br><span class="line">        student1.setName(&quot;李四&quot;);</span><br><span class="line">        student1.setAge(24);</span><br><span class="line">        String name1 = student1.getName();</span><br><span class="line">        int age1 = student1.getAge();</span><br><span class="line">        System.out.println(&quot;姓名：&quot; + name1 + &quot;=== 年龄&quot; + age1);</span><br><span class="line">        student1.eat();</span><br><span class="line">        student1.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出：</span><br><span class="line">姓名：张三=== 年龄20</span><br><span class="line">吃饭</span><br><span class="line">睡觉</span><br><span class="line">-------------------</span><br><span class="line">姓名：李四=== 年龄24</span><br><span class="line">吃饭</span><br><span class="line">睡觉</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组的定义及操作、递归</title>
      <link href="/2019/04/08/%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%93%8D%E4%BD%9C%E3%80%81%E9%80%92%E5%BD%92/"/>
      <url>/2019/04/08/%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%93%8D%E4%BD%9C%E3%80%81%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>概念：数组是存储同一种数据类型多个元素的集合。也可以看成是一个容器。</p><p>数组既可以存储基本数据类型，也可以存储引用数据类型</p><h1 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h1><p>定义格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式一：数据类型[] 数组名；</span><br><span class="line"></span><br><span class="line">格式二：数据类型 数组名[];</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[ ] a; //定义了一个int类型的数组a；</span><br><span class="line"></span><br><span class="line">int a[ ]; //定义了一个int类型的数组a；</span><br></pre></td></tr></table></figure><p>案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //数组：你可以一个容器，他用来存储一组相同类型的数据。</span><br><span class="line">        //数组的定义语法</span><br><span class="line">        //方式1：动态的定义方式，由我们规定数组的长度，由系统赋默认值</span><br><span class="line">        //创建一个int类型的数组</span><br><span class="line">        //当我们创建好了数组后，系统会给分配索引（角标）从0开始</span><br><span class="line">        int[] arr=new int[10];</span><br><span class="line">        //往数组中放入数据 通过数组的索引往里面存数据</span><br><span class="line">        arr[0]=10;</span><br><span class="line">        arr[1]=20;</span><br><span class="line">        arr[2]=30;</span><br><span class="line">        //取数组中的元素</span><br><span class="line">        int num=arr[2];</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(arr[4]);</span><br><span class="line">        System.out.println(arr[5]);</span><br><span class="line"></span><br><span class="line">        //语法2</span><br><span class="line">        boolean bs[]=new boolean[2];</span><br><span class="line">        bs[0]=true;</span><br><span class="line">        System.out.println(bs[0]);</span><br><span class="line">        System.out.println(bs[1]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数组可以存储基本数据类型，也可以存储引用数据类型。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr1 = new int[3];</span><br><span class="line">        arr1[0] = 10;</span><br><span class="line">        arr1[1] = 20;</span><br><span class="line">        System.out.println(arr1[1]);</span><br><span class="line"></span><br><span class="line">        int[] arr2 = new int[3];</span><br><span class="line">        arr2[0] = 100;</span><br><span class="line">        arr2[1] = 200;</span><br><span class="line">        System.out.println(arr2[1]);</span><br><span class="line"></span><br><span class="line">        System.out.println(arr1);</span><br><span class="line">        System.out.println(arr2);</span><br><span class="line"></span><br><span class="line">        //数据类型：基本数据类型和引用数据类型</span><br><span class="line">        //引用数据类型，你使用new关键字初始化的数据 数组 类 接口 枚举</span><br></pre></td></tr></table></figure><h2 id="Java中的内存分配以及栈和堆的区别"><a href="#Java中的内存分配以及栈和堆的区别" class="headerlink" title="Java中的内存分配以及栈和堆的区别"></a>Java中的内存分配以及栈和堆的区别</h2><ul><li><p>栈: 存放的是局部变量</p><p>局部变量：在方法定义中或者方法声明上的变量都是局部变量。</p></li><li><p>堆: 存放的是所有new出来的东西</p></li><li><p>特点：</p><pre><code>a: 每一个new出来的东西都会为其分配一个地制值。  b: 每一个变量都有一个默认的值</code></pre></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">byte，short，int，long --------&gt;0</span><br><span class="line">float，double ----------------------&gt;0.0</span><br><span class="line">char –----------------------------------&gt;‘\u0000’</span><br><span class="line">boolean ------------------------------&gt; false</span><br><span class="line">引用数据类型------------------------&gt; null</span><br></pre></td></tr></table></figure><p>使用完毕就变成了垃圾，等待垃圾回收器对其回收</p><ul><li>方法区</li><li>本地方法区:(和系统相关)</li><li>寄存器:(cpu使用)</li></ul><h3 id="两个数组的内存图"><a href="#两个数组的内存图" class="headerlink" title="两个数组的内存图"></a>两个数组的内存图</h3><p><img src="D:\Hexo\blog\zhaoBlog\source\_posts\数组的定义及操作\两个数组的内存图.jpg" alt="两个数组的内存图"></p><h3 id="三个数组的内存图"><a href="#三个数组的内存图" class="headerlink" title="三个数组的内存图"></a>三个数组的内存图</h3><p><img src="D:\Hexo\blog\zhaoBlog\source\_posts\数组的定义及操作\三个数组的内存图.png" alt="三个数组的内存图"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">执行流程：</span><br><span class="line">定义第一个数组,定义完毕后，给数组元素赋值。赋值完毕后，再输出数组名称和元素</span><br><span class="line">定义第二个数组,定义完毕后，给数组元素赋值。赋值完毕后，再输出数组名称和元素</span><br><span class="line">定义第三个数组,把第一个数组的地址值赋值给它。(注意类型一致)，通过第三个数组的名称去把元素重新赋值</span><br><span class="line">最后，再次输出第一个数组数组名称和元素</span><br></pre></td></tr></table></figure><h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><p>Java中数组必须先初始化才能使用，即为数组中的元素分配内存空间并赋值</p><p>初始化的分类：</p><p>​    （1）动态初始化: 只指定长度，由系统给出初始化值</p><p>​    （2）静态初始化: 给出初始化值，由系统决定长度</p><p>​    注意：两种初始化方式只能使用一种，不能动静结合</p><h3 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h3><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名 = new 数据类型[数组长度];</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = new int[3]; //定义了一个int类型的数组arr，这个数组可以存放4个int类型的值。</span><br></pre></td></tr></table></figure><h4 id="动态初始化的内存图解"><a href="#动态初始化的内存图解" class="headerlink" title="动态初始化的内存图解"></a>动态初始化的内存图解</h4><p><img src="D:\Hexo\blog\zhaoBlog\source\_posts\数组的定义及操作\动态初始化数组的内存图.png" alt="动态初始化数组的内存图"></p><h3 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h3><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名 = new 数据类型[]&#123;元素1,元素2,…&#125;;</span><br></pre></td></tr></table></figure><p>举例： i</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = new int[]&#123;1,2,3&#125;;</span><br></pre></td></tr></table></figure><p>简化格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名 = &#123;元素1,元素2,…&#125;;</span><br></pre></td></tr></table></figure><p>举例： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = &#123;1,2,3&#125;;</span><br></pre></td></tr></table></figure><h4 id="静态初始化内存图"><a href="#静态初始化内存图" class="headerlink" title="静态初始化内存图"></a>静态初始化内存图</h4><p><img src="D:\Hexo\blog\zhaoBlog\source\_posts\数组的定义及操作\数组的静态初始化的内存图解.bmp" alt="数组的静态初始化的内存图解"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayDemo03 &#123;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line"> int[] arr = &#123; 1, 2, 3, 4 &#125;; // 静态初始化</span><br><span class="line"> // 下面的代码是依次访问数组中的元素</span><br><span class="line"> System.out.println(&quot;arr[0] = &quot; + arr[0]);</span><br><span class="line"> System.out.println(&quot;arr[1] = &quot; + arr[1]);</span><br><span class="line"> System.out.println(&quot;arr[2] = &quot; + arr[2]);</span><br><span class="line"> System.out.println(&quot;arr[3] = &quot; + arr[3]);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一维数组常用操作"><a href="#一维数组常用操作" class="headerlink" title="一维数组常用操作"></a>一维数组常用操作</h2><h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr=&#123;10,20,50,40,102&#125;;</span><br><span class="line">        //数组的遍历</span><br><span class="line">        for(int i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">           System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组获取最值"><a href="#数组获取最值" class="headerlink" title="数组获取最值"></a>数组获取最值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        //获取数组中的最大值或最小值</span><br><span class="line">        int[] arr = &#123;10, 20, 50, 40, 102&#125;;</span><br><span class="line">        int max = getMax(arr);</span><br><span class="line">        System.out.println(&quot;最大值是&quot; + max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int getMax(int[] arr)&#123;</span><br><span class="line">    int max = arr[0];</span><br><span class="line">    for(int i = 1; i&lt;arr.length; i++)&#123;</span><br><span class="line">        if(arr[i]&gt;arr[0])&#123;</span><br><span class="line">max = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组反转"><a href="#数组反转" class="headerlink" title="数组反转"></a>数组反转</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayDemo3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //数组元素反转(就是把元素对调)</span><br><span class="line">        int[] arr = &#123;10, 20, 30, 40, 50&#125;; //50 40 30 20 10</span><br><span class="line"></span><br><span class="line">        for (int i = 0, j = arr.length - 1; i &lt; j; i++, j--) &#123;</span><br><span class="line">            int t = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reverseArray(arr);</span><br><span class="line">        showArray(arr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //数组元素反转</span><br><span class="line">    private static void reverseArray(int[] arr) &#123;</span><br><span class="line">        //分析：首尾元素值交换，遍历一半</span><br><span class="line">        for (int i = 0; i &lt; arr.length / 2; i++) &#123;</span><br><span class="line">            //采用中间变量进行值交换</span><br><span class="line">            int t = arr[i];</span><br><span class="line">            arr[i] = arr[arr.length - 1 - i];</span><br><span class="line">            arr[arr.length - 1 - i] = t;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//遍历数组</span><br><span class="line">    private static void showArray(int[] arr) &#123;</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + &quot;,&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组查表法"><a href="#数组查表法" class="headerlink" title="数组查表法"></a>数组查表法</h3><p>根据键盘录入索引,查找对应星期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class ArrayDemo8 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //数组查表法(根据键盘录入索引, 查找对应星期)</span><br><span class="line">        //根据索引查元素</span><br><span class="line">        String[] arr = &#123;&quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;, &quot;星期天&quot;&#125;;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入一个整数 1----7&quot;);</span><br><span class="line">        int index = scanner.nextInt();</span><br><span class="line">        String str = getElementByArray(index, arr);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String getElementByArray(int index, String[] arr) &#123;</span><br><span class="line">        if (index &gt;= 1 &amp;&amp; index &lt;= 7) &#123;</span><br><span class="line">            return arr[index - 1];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &quot;查无此元素&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组基本查找"><a href="#数组基本查找" class="headerlink" title="数组基本查找"></a>数组基本查找</h3><p>查找指定元素第一次在数组中出现的索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class ArrayDemo9 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //根据元素查索引</span><br><span class="line">        String[] arr = &#123;&quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;, &quot;星期天&quot;&#125;;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入一个星期&quot;);</span><br><span class="line">        String str = scanner.nextLine();//获取用户输入的字符串</span><br><span class="line">        int index = getIndex(str, arr);</span><br><span class="line">        System.out.println(&quot;该元素的索引是&quot; + index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int getIndex(String str, String[] arr) &#123;</span><br><span class="line">        //遍历数组</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            if (str.equals(arr[i])) &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1; // 一般喜欢用 -1 代表没找到</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组操作的两个常见小问题越界和空指针"><a href="#数组操作的两个常见小问题越界和空指针" class="headerlink" title="数组操作的两个常见小问题越界和空指针"></a>数组操作的两个常见小问题越界和空指针</h1><h2 id="ArrayIndexOutOfBoundsException-数组索引越界异常"><a href="#ArrayIndexOutOfBoundsException-数组索引越界异常" class="headerlink" title="ArrayIndexOutOfBoundsException:数组索引越界异常"></a>ArrayIndexOutOfBoundsException:数组索引越界异常</h2><p>每个数组的索引都有一个范围，即0~length-1。在访问数组的元素时，索引不能超出这个范围，否则程序会报错，如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayDemo06 &#123;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line"> int[] arr = new int[4]; // 定义一个长度为4的数组</span><br><span class="line"> System.out.println(&quot;arr[0]=&quot; + arr[4]); // 通过角标4访问数组元素</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>出现这个异常的原因是数组的长度为4，其索引范围为0~3，而上述代码中的第4行代码使用索引4来访问元素时超出了数组的索引范围。</p><h2 id="NullPointerException-空指针异常"><a href="#NullPointerException-空指针异常" class="headerlink" title="NullPointerException:空指针异常"></a>NullPointerException:空指针异常</h2><p>在使用变量引用一个数组时，变量必须指向一个有效的数组对象，如果该变量的值为null，则意味着没有指向任何数组，此时通过该变量访问数组的元素会出现空指针异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = new int[]&#123;10, 20&#125;;</span><br><span class="line">        arr = null;// 人为置空</span><br><span class="line">        //NullPointerException 空指针异常</span><br><span class="line">        int length = arr.length;</span><br><span class="line">        System.out.println(length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><p>概念：二维数组其实就是每一个元素为一维数组的数组</p><p>定义格式：</p><pre><code>数据类型[][] 变量名 = new 数据类型[m][n]m表示这个二维数组有多少个一维数组 必须写上n表示每一个一维数组的元素个数 可不写</code></pre><p>举例：</p><pre><code>int[][] arr = new int[3][2];表示定义了一个二维数组arr，这个二维数组有3个一维数组，名称是arr[0],arr[1],arr[2]，每个一维数组有2个元素，可以通过arr[m][n]来获取</code></pre><p>注意事项：</p><pre><code>（1）以下格式也可以表示二维数组：数据类型 数组名[] [] = new 数据类型[m] [n];数据类型[] 数组名[] = new 数据类型[m] [n];（2）int[] x,y[]; //定义了两个数组 一个是一维数组x= new int[3],另一个是二维数组y=new int[3] []</code></pre><h2 id="二维数组的内存图"><a href="#二维数组的内存图" class="headerlink" title="二维数组的内存图"></a>二维数组的内存图</h2><p><img src="D:\Hexo\blog\zhaoBlog\source\_posts\数组的定义及操作\二维数组的内存图.png" alt="二维数组的内存图"></p><h2 id="二维数组常用操作"><a href="#二维数组常用操作" class="headerlink" title="二维数组常用操作"></a>二维数组常用操作</h2><h3 id="二维数组遍历"><a href="#二维数组遍历" class="headerlink" title="二维数组遍历"></a>二维数组遍历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        int[][] arr = &#123;&#123;2, 4&#125;, &#123;10, 30&#125;, &#123;10, 30, 40&#125;, &#123;10, 1&#125;&#125;;</span><br><span class="line">        //二维数组的遍历</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            //System.out.println(arr[i]); //一维数组</span><br><span class="line">            for (int j = 0; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">                System.out.println(arr[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打印杨辉三角"><a href="#打印杨辉三角" class="headerlink" title="打印杨辉三角"></a>打印杨辉三角</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //B:</span><br><span class="line">        //需求：打印杨辉三角形(行数可以键盘录入)</span><br><span class="line">        //</span><br><span class="line">        //1</span><br><span class="line">        //1 1</span><br><span class="line">        //1 2 1</span><br><span class="line">        //1 3 3 1</span><br><span class="line">        //1 4 6 4 1</span><br><span class="line">        //1 5 10 10 5 1</span><br><span class="line">        //</span><br><span class="line">        /**</span><br><span class="line">         * 分析规律：</span><br><span class="line">         * 1.每一行的第一个数和最后一个数都是1</span><br><span class="line">         * 2.从第三行开始，中间的数等于我上一行的前一列的数和我上一行本列的数之和</span><br><span class="line">         */</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入行数&quot;);</span><br><span class="line">        int n = sc.nextInt();</span><br><span class="line">        //1.第一个数和最后一个数都是1</span><br><span class="line">        //2.第三行开始，中间的数等于我上一行的前一列的数和我上一行本列的数之和</span><br><span class="line">        int[][] arr=new int[n][n]; //定义一个数组，行列数都一样</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i][0]=1; //将每一行的第一个数，置成1</span><br><span class="line">            arr[i][i]=1; //将三角形的每一行的最后一个元素置成1</span><br><span class="line">        &#125;</span><br><span class="line">        //计算中间元素</span><br><span class="line">        for (int i =2; i &lt; arr.length; i++) &#123;</span><br><span class="line">            for (int j =1; j &lt;= i-1; j++) &#123;</span><br><span class="line">                //第三行开始，中间的数等于我上一行的前一列的数和我上一行本列的数之和</span><br><span class="line">               arr[i][j]=arr[i-1][j-1]+arr[i-1][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //遍历二维数组</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt;=i; j++) &#123;</span><br><span class="line">                System.out.print(arr[i][j]+&quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归概述: 方法定义中调用方法本身的现象<br>递归注意事项：</p><ul><li>​    要有出口，否则就是死递归</li><li>​    次数不能太多，否则就内存溢出</li></ul><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>案例：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问第二十个月的兔子对数为多少？<br>由此可见兔子对象的数据是：1 , 1 , 2 , 3 , 5 , 8 …</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //  1 1 2 3 5 8 13 21 从第三个数开始，这个数等于前两个数之和 （斐波那契数列）</span><br><span class="line">        //递归来做</span><br><span class="line">        int sum = sumRabbit(20);</span><br><span class="line">        System.out.println(&quot;兔子的对数&quot; + sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int sumRabbit(int i) &#123;</span><br><span class="line">        if (i == 1 || i == 2) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return sumRabbit(i - 1) + sumRabbit(i - 2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="根据索引查元素"><a href="#根据索引查元素" class="headerlink" title="根据索引查元素"></a>根据索引查元素</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayDemo8 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //A:</span><br><span class="line">        //案例演示:</span><br><span class="line">        //数组查表法(根据键盘录入索引, 查找对应星期)</span><br><span class="line">        //根据索引查元素</span><br><span class="line">        //获取跟打印输出是两个概念</span><br><span class="line">        String[] arr = &#123;&quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;, &quot;星期天&quot;&#125;;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入一个整数 1----7&quot;);</span><br><span class="line">        int index = scanner.nextInt();</span><br><span class="line">        String str = getElementByArray(index, arr);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String getElementByArray(int index, String[] arr) &#123;</span><br><span class="line">        if (index &gt;= 1 &amp;&amp; index &lt;= 7) &#123;</span><br><span class="line">            return arr[index - 1];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &quot;查无此元素&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="根据元素查索引"><a href="#根据元素查索引" class="headerlink" title="根据元素查索引"></a>根据元素查索引</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayDemo9 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //ctrl+alt+O 优化导包，没有的包导进来，没有用到的包删掉</span><br><span class="line">        //根据元素查索引</span><br><span class="line">        String[] arr = &#123;&quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;, &quot;星期天&quot;&#125;;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入一个星期&quot;);</span><br><span class="line">        String str = scanner.nextLine();//获取用户输入的字符串</span><br><span class="line">        int index = getIndex(str, arr);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;该元素的索引是&quot; + index);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int getIndex(String str, String[] arr) &#123;</span><br><span class="line">        //遍历数组</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            if (str.equals(arr[i])) &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return -1; // 一般喜欢用 -1 代表没找到</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="在数组中查元素索引"><a href="#在数组中查元素索引" class="headerlink" title="在数组中查元素索引"></a>在数组中查元素索引</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr=new int[]&#123;11,32,55,47,55,79,23&#125;;</span><br><span class="line"></span><br><span class="line">        int num = 55;</span><br><span class="line">        int index = getIndex(num,arr);</span><br><span class="line"></span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line">    private static int getIndex(int num,int[] arr)&#123;</span><br><span class="line">        for (int i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">            if(num==arr[i])&#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>键盘录入数据、流程控制语句、方法、方法重载</title>
      <link href="/2019/04/05/%E9%94%AE%E7%9B%98%E5%BD%95%E5%85%A5%E6%95%B0%E6%8D%AE%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
      <url>/2019/04/05/%E9%94%AE%E7%9B%98%E5%BD%95%E5%85%A5%E6%95%B0%E6%8D%AE%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="键盘录入"><a href="#键盘录入" class="headerlink" title="键盘录入"></a>键盘录入</h1><p>1、在类（class）上面导包</p><p>​    格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br></pre></td></tr></table></figure><p>2、创建键盘录入对象</p><p>​    格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = new Scanner(System.in);</span><br></pre></td></tr></table></figure><p>3、通过对象的方法获取键盘录入的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x = sc.nextInt();</span><br><span class="line">String str = sc.nextLine();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="Java语言三种结构"><a href="#Java语言三种结构" class="headerlink" title="Java语言三种结构"></a>Java语言三种结构</h1><p>Java语言三种结构：顺序结构、选择结构、循环结构</p><h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><p>是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的，即<strong>写在前面的先执行，写在后面的后执行</strong>，从上往下，依次执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;a&quot;);</span><br><span class="line">System.out.println(&quot;b&quot;);</span><br><span class="line">System.out.println(&quot;c&quot;);</span><br><span class="line">//顺序结构，自上而下执行，依次输出a,b,c</span><br></pre></td></tr></table></figure><h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><p>选择结构包括if语句和switch语句</p><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>​    <strong>格式一：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(boolean类型的表达式或值)&#123;</span><br><span class="line">语句体  //当()内表达式为true时进入大括号执行语句体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(4&gt;3)&#123;</span><br><span class="line">System.out.println(&quot;执行的该语句&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//  控制台会打印出&quot;执行的该语句&quot;</span><br></pre></td></tr></table></figure><p>​    <strong>格式二：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(条件)&#123;</span><br><span class="line">条件为真，执行这个括号里面的代码</span><br><span class="line">&#125;else&#123;</span><br><span class="line">条件为假，执行这个括号里面的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(10+2&gt;5-3)&#123;</span><br><span class="line">System.out.println(&quot;这是真的&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">System.out.println(&quot;这是假的&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 运行结果为&quot;这是真的&quot;</span><br></pre></td></tr></table></figure><p>​    三元运算符能实现的，都可以采用if语句实现，但反之不成立</p><p>​    什么时候if语句实现不能用三元改进呢? 当if语句控制的操作是一个输出语句的时候就不能改写</p><p>​    <strong>格式三：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(条件1)&#123;</span><br><span class="line">    语句体1 //满足条件1则执行此处</span><br><span class="line">&#125;else if(条件2)&#123;</span><br><span class="line">    语句体2  //满足条件2则执行此处</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">else&#123;</span><br><span class="line">    语句体n+1  //条件1、2、...n都不满足则执行此处语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    案例：获取三个数最大值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int a=100;</span><br><span class="line">int b=10;</span><br><span class="line">int c=18;</span><br><span class="line">if(a&gt;b&amp;&amp;a&gt;c)&#123;</span><br><span class="line">max=a;</span><br><span class="line">&#125;else if(b&gt;a&amp;&amp;b&gt;c)&#123;</span><br><span class="line">max=b;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">max=c;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;最大值是：&quot;+max);</span><br></pre></td></tr></table></figure><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">switch(常量/变量)&#123;</span><br><span class="line">case 值:</span><br><span class="line">        执行的代码</span><br><span class="line">break;</span><br><span class="line">case 值:</span><br><span class="line">        执行的代码</span><br><span class="line">break;</span><br><span class="line">case 值:</span><br><span class="line">        执行的代码</span><br><span class="line">break;</span><br><span class="line">case 值:</span><br><span class="line">        执行的代码</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">执行的代码</span><br><span class="line">break;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>1、switch语句支持的表达式的数据类型：byte 、short、 int、 char、JDK5以后可以是枚举、JDK7以后可以是String</p><p>2、case 后面的只能是常量，多个case后面的值不能出现相同的</p><p>3、default 可以写也可以不写，且功能的执行与位置无关，但是建议在最后，当所有case项都没有匹配上就会执行</p><p>4、break 结束整个switch语句，如果没有 break 会发生 case穿透，这种现象你可以利用</p><p>5、switch语句的结束条件：遇到break就结束了或者执行到末尾结束</p></blockquote><p>案例一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int x = 2;</span><br><span class="line">int y = 3;</span><br><span class="line">switch(x)&#123;</span><br><span class="line">default:</span><br><span class="line">y++;</span><br><span class="line">case 3:</span><br><span class="line">y++;</span><br><span class="line">case 4:</span><br><span class="line">y++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;y=&quot;+y);//6</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">int x = 2;</span><br><span class="line">int y = 3;</span><br><span class="line">switch(x)&#123;</span><br><span class="line">default:</span><br><span class="line">y++;</span><br><span class="line">break;</span><br><span class="line">case 3:</span><br><span class="line">y++;</span><br><span class="line">case 4:</span><br><span class="line">y++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;y=&quot;+y); // 4</span><br></pre></td></tr></table></figure><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>循环结构包括for循环、while循环和do…while循环</p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(初始化表达式语句;判断条件语句;控制条件语句) &#123;</span><br><span class="line">循环体语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程：</p><pre><code>a:执行初始化表达式语句b:执行判断条件语句,看其返回值是true还是false，如果是true，就继续执行，如果是false，就结束循环c:执行循环体语句d:执行控制条件语句e:回到b继续执行</code></pre><p>注意：初始化表达式语句只执行一次</p><p>案例：打印1~100的数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1; i&lt;=100; i++)&#123;</span><br><span class="line">    System.out.println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(判断条件语句) &#123;</span><br><span class="line">循环体语句;</span><br><span class="line">控制条件语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程：先判断条件语句是否为true，若为true，则进入大括号执行循环语句和控制条件语句</p><p>案例：求1—100之间的和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int i=1;</span><br><span class="line">int sum=0;</span><br><span class="line">while (j&lt;=100)&#123;</span><br><span class="line">   sum+=j;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;和是 &quot;+sum);</span><br></pre></td></tr></table></figure><h3 id="do-…while循环"><a href="#do-…while循环" class="headerlink" title="do …while循环"></a>do …while循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">循环体语句;</span><br><span class="line">控制条件语句;</span><br><span class="line">&#125;while(判断条件语句);</span><br></pre></td></tr></table></figure><p>执行流程：先执行do里面的代码一次，然后再去判断，while括号里面的条件是否成立，如果成立，就继续执行{}里面的语句，如果条件不成立，则循环结束</p><p>案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i=2;</span><br><span class="line">do&#123;</span><br><span class="line">    System.out.println(&quot;你好&quot;);</span><br><span class="line">    i--;</span><br><span class="line">&#125;while (i&gt;2); </span><br><span class="line">//执行一次do里面的代码</span><br></pre></td></tr></table></figure><p><strong>三种循环语句的区别</strong></p><p>(1): do…while循环至少执行一次循环体。而for,while循环必须先判断条件是否成立，然后决定是否执行循环体语句。</p><p>(2): 如果你想在循环结束后，继续使用控制条件的那个变量，用while循环，否则用for循环。</p><p><strong>死循环</strong></p><p>当控制条件语句控制的那个变量丢失时，循环结构可能进入死循环</p><p>两种最简单的死循环格式:</p><p>​    while(true){…}</p><p>​    for(; ; ){…}</p><h1 id="控制跳转语句"><a href="#控制跳转语句" class="headerlink" title="控制跳转语句"></a>控制跳转语句</h1><p>什么是控制跳转语句：Java中的goto是保留字，目前不能使用。虽然没有goto语句可以增强程序的安全性，但是也带来很多不便， 比如想在某个循环执行到某一步的时候就结束，现在就做不了这件事情。为了弥补这个缺陷，Java就提供了break（中断），continue（继续）和return（返回）来实现控制语句的跳转和中断</p><ul><li><h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p>(1):在选择结构switch语句中</p><p>(2):在循环语句中</p><p>​    作用：常用于退出单层循环</p><p>​    注意：离开使用场景的存在是没有意义的</p></li><li><h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><p>​    在循环语句中</p><p>​    作用：跳出一次循环，执行下一步操作</p><p>​    注意：离开使用场景的存在是没有意义的</p><p>案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for(int x=1; x&lt;=10; x++) &#123;</span><br><span class="line">if(x%3==0) &#123;</span><br><span class="line">//在此处填写代码</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(“Java”);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//我想在控制台输出2次:“Java“----braak;</span><br><span class="line">//我想在控制台输出7次:“Java“----continue;</span><br><span class="line">//我想在控制台输出13次:“Java“----System.out.println(“Java”);</span><br></pre></td></tr></table></figure></li><li><h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><p>​    作用：return 就是退出一个方法</p></li></ul><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>​    为了解决代码重复编写的问题，可以将一个功能的代码提取出来放在一个{}中，并为这段代码起个名字，所提取出来的代码可以被看作是程序中定义的一个方法，就是对一段功能逻辑的封装，以实现重复调用。</p><ul><li>格式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名1，参数类型 参数名2 …)&#123;</span><br><span class="line">    方法体;</span><br><span class="line">    return 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>举例：定义一个方法求1~n的和并返回值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static int getSum(int n)&#123;</span><br><span class="line">int sum=0;</span><br><span class="line">    for(int i = 1; i&lt;=n; i++)&#123;</span><br><span class="line">sum+=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;&#125;</span><br></pre></td></tr></table></figure><p>主方法是一个程序的入口，主方法是JVM来调用的，一个类中只能有一个主方法</p><ul><li>实参与形参</li></ul><p>实参：调用方法时，传入的参数，叫做实际参数，简称实参，传常量，变量都可以。</p><p>形参：定义方法括号里面的参数，叫做形式参数，简称形参。形参的作用是，调用方法时，接收传过来的实参，多个形参你用逗号隔开。</p><ul><li>注意</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法不调用不执行</span><br><span class="line">方法与方法是平级关系，不能嵌套定义</span><br><span class="line">方法定义的时候参数之间用逗号隔开</span><br><span class="line">方法调用的时候不用在传递数据类型</span><br><span class="line">如果方法有明确的返回值，一定要由return带回一个值</span><br></pre></td></tr></table></figure><ul><li>案例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//  需求：根据键盘录入的数据输出对应的乘法表</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class MyTest &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入一个行数&quot;);</span><br><span class="line">        int i = sc.nextInt();</span><br><span class="line">        //调用方法</span><br><span class="line">        showChengFaBiao(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void showChengFaBiao(int a) &#123;</span><br><span class="line">        for (int i = 1; i &lt;= a; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= i; j++) &#123;</span><br><span class="line">                System.out.print(j + &quot;*&quot; + i + &quot;=&quot; + (j * i) + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h1><p>在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同（参数个数或者参数类型不同），与返回值无关。调用的时候，会根据参数个数和参数类型去匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static int add(int i, int i1) &#123;</span><br><span class="line">        System.out.println(&quot;两个int参数方法调用了&quot;);</span><br><span class="line">        return i + i1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static double add(int i, double i1) &#123;</span><br><span class="line">        System.out.println(&quot;一个int 一个double调用了&quot;);</span><br><span class="line">        return i + i1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int add(int i, int i1, int i2, int i3) &#123;</span><br><span class="line"></span><br><span class="line">        return i + i1 + i2 + i3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int add(int i, int i1, int i2) &#123;</span><br><span class="line"></span><br><span class="line">        return i + i1 + i2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进制、常量、变量、数据类型、运算符</title>
      <link href="/2019/04/02/%E8%BF%9B%E5%88%B6%E3%80%81%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2019/04/02/%E8%BF%9B%E5%88%B6%E3%80%81%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h1><p>二进制：由0、1组成，逢二进一，以0b开头，</p><p>八进制：由0~7组成，逢八进一，以0开头</p><p>十进制：由0~9组成，逢十进一，默认是十进制</p><p>十六进制：由0-9,A-F组成，逢十六进一，以0X开头</p><p>案例：输出不同进制表现10的数据<br>二进制：0b10<br>八进制：010<br>十进制：10<br>十六进制：0x10</p><h1 id="任意进制到十进制的转换"><a href="#任意进制到十进制的转换" class="headerlink" title="任意进制到十进制的转换"></a>任意进制到十进制的转换</h1><p>规则：系数*基数^权数次幂相加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二进制转换为十进制：0b101----&gt; 1*2^0+0*2^1+1*2^2=5</span><br></pre></td></tr></table></figure><p>其他进制转换到十进制以此类推</p><h1 id="十进制到任意进制的转换"><a href="#十进制到任意进制的转换" class="headerlink" title="十进制到任意进制的转换"></a>十进制到任意进制的转换</h1><p>规则：除基取余 直到商为0 余数反转</p><p>十进制转换为二进制：</p><p>5/2商2余1</p><p>2/2商1余0</p><p>1/2商0余1</p><p>余数反转（自下而上）的二进制为:0b101</p><h1 id="原码-反码-补码"><a href="#原码-反码-补码" class="headerlink" title="原码 反码 补码"></a>原码 反码 补码</h1><p>原码：即二进制定点表示法</p><p>反码：正数的反码与其原码相同；负数的反码是除符号位外对其逐位取反</p><p>补码：正数的补码与其原码相同；负数的补码是在其反码的末位加1</p><p>案例：</p><p>​    原码：1001011</p><p>​    反码：1110100（除符号位外对位取反）</p><p>​    补码：1110101（反码加1）</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="什么是变量"><a href="#什么是变量" class="headerlink" title="什么是变量"></a>什么是变量</h2><ul><li>在程序执行的过程中，在某个范围内其值可以发生改变的量，定义一个变量，其实就是开辟了一个内存空间</li><li>变量本质上是内存中的一块空间，这块空间“有数据类型”、“有名字”、“有字面值”</li><li>变量包括：数据类型  名字  字面值；</li><li>变量是内存中存储数据的最基本的单元</li></ul><h2 id="数据类型的作用：指导数据在内存中开辟多大的空间"><a href="#数据类型的作用：指导数据在内存中开辟多大的空间" class="headerlink" title="数据类型的作用：指导数据在内存中开辟多大的空间"></a>数据类型的作用：指导数据在内存中开辟多大的空间</h2><ul><li>不同的数据有不同的类型，不同的数据类型底层会分配不同大小的空间</li><li>数据类型是指导程序在运行阶段应该分配多大的内存空间</li><li><strong>变量要求：变量中存储的具体的“数据”必须和变量的“数据类型”一致</strong></li></ul><h2 id="定义格式"><a href="#定义格式" class="headerlink" title="定义格式"></a>定义格式</h2><ul><li>数据类型 变量名 = 变量值   </li></ul><h2 id="变量声明后怎么赋值"><a href="#变量声明后怎么赋值" class="headerlink" title="变量声明后怎么赋值"></a>变量声明后怎么赋值</h2><p>变量名 = 字面值；</p><p>=等号是一个运算符，叫做赋值运算符，赋值运算符先运算等号右边的表达式，表达式执行结束后的结果赋值给左边的变量。</p><p>声明和赋值可以放到一起完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int i = 10；</span><br></pre></td></tr></table></figure><h2 id="变量赋值之后可以重新赋值，变量的值可变化"><a href="#变量赋值之后可以重新赋值，变量的值可变化" class="headerlink" title="变量赋值之后可以重新赋值，变量的值可变化"></a>变量赋值之后可以重新赋值，变量的值可变化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i = 10；</span><br><span class="line">System.out.println(i);   //10</span><br><span class="line">i = 20;</span><br><span class="line">System.out.println(i);   //20</span><br><span class="line">i = 30;</span><br><span class="line">System.out.println(i);  //30</span><br></pre></td></tr></table></figure><p><strong>有了变量的概念之后，内存空间得到了重复的使用</strong></p><h2 id="通常访问一个变量包括两种访问形式"><a href="#通常访问一个变量包括两种访问形式" class="headerlink" title="通常访问一个变量包括两种访问形式"></a>通常访问一个变量包括两种访问形式</h2><ul><li>第一种：读取变量中保存的具体数据  get/获取</li><li>第二种：修改变量中保存的具体数据  set/设置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = 20;  //set</span><br><span class="line">System.out.println(i); //get</span><br></pre></td></tr></table></figure><h2 id="变量在一行上可以声明多个"><a href="#变量在一行上可以声明多个" class="headerlink" title="变量在一行上可以声明多个"></a>变量在一行上可以声明多个</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a,b,c</span><br><span class="line">//一行上可以同时声明多个变量 </span><br><span class="line">int a,b,c=300;</span><br><span class="line">//这一行说明只是给c赋值了，a,b并没有</span><br></pre></td></tr></table></figure><h2 id="变量必须先声明，再赋值，才能访问"><a href="#变量必须先声明，再赋值，才能访问" class="headerlink" title="变量必须先声明，再赋值，才能访问"></a>变量必须先声明，再赋值，才能访问</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Varible &#123;</span><br><span class="line">    public static void main (String[] args)&#123;</span><br><span class="line">         int i； //程序执行到这里，内存空间没有开辟出来，变量i并没有初始化</span><br><span class="line">         //所以没有赋值之前是无法访问的</span><br><span class="line">        // System.out.println(i);   //编译报错</span><br><span class="line">         </span><br><span class="line">         //给i赋值，完成初始化，内存开辟</span><br><span class="line">         i = 100；</span><br><span class="line">         System.out.println(i);//100                </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量的分类"><a href="#变量的分类" class="headerlink" title="*变量的分类"></a>*变量的分类</h3><p><strong>根据变量声明的位置来分类：</strong></p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>​        在方法体当中声明的变量叫做局部变量</p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>​        在方法体外（类体内）声明的变量叫成员变量</p><ul><li><strong>在不同作用域中，变量名可以相同，就近原则</strong></li></ul><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ul><li><p>不同数据数据类型的数据占用空间大小不同。</p></li><li><p>数据类型作用是指导JVM在运行程序时给数据分配多大的内存空间。</p></li><li><p>Java中数据类型的分类：</p></li></ul><p>​        基本数据类型</p><p>​        引用数据类型</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="整数型"><a href="#整数型" class="headerlink" title="整数型"></a>整数型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类型          字节数范围</span><br><span class="line">byte  1(8bit)       -128  ~  127</span><br><span class="line">short 2(16bit)   -2^15 ~  2^15 - 1</span><br><span class="line">int 4(32bit)      -2^31 ~  2^31 - 1</span><br><span class="line">long 8(64bit)      -2^63 ~  2^63 - 1</span><br></pre></td></tr></table></figure><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型          字节数            范围</span><br><span class="line">float       4(32bit)      -3.403*10^38  ~ 3.403*10^38</span><br><span class="line">double     8(64bit)  -1.798*10^308 ~1.798*10^308</span><br></pre></td></tr></table></figure><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类型          字节数            范围</span><br><span class="line">char       2(16bit)   0 ~ 2^16 - 1 = 65535</span><br></pre></td></tr></table></figure><p>​    <strong>换行符   \n</strong></p><p><strong>制表符 \t</strong></p><h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类型          字节数    </span><br><span class="line">boolean        1</span><br></pre></td></tr></table></figure><p> <strong>整数默认是int类型的 ， 浮点数默认是 double类型的</strong> </p><h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><p>如数组，接口，类等</p><p>注意：</p><p>​    未初始化的变量不能使用<br>​    同一作用域内不能有两个同名变量<br>​    同一行可定义多个变量，但不建议</p><h1 id="java数据类型的自动类型提升与强制转换"><a href="#java数据类型的自动类型提升与强制转换" class="headerlink" title="java数据类型的自动类型提升与强制转换"></a>java数据类型的自动类型提升与强制转换</h1><h2 id="自动类型提升"><a href="#自动类型提升" class="headerlink" title="自动类型提升"></a>自动类型提升</h2><p>byte short char 在参与数学运算时，会自动提升为int类型，如果还有long ,float double 参与运算则会相应的提升为 long float double ,布尔类型不参与数学运算，byte short char 之间不发生转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">byte a=10;</span><br><span class="line">short b=20;</span><br><span class="line">byte num=a+b;  //报错,在运算时会转换为int类型，byte类型的num装不下int类型的数据</span><br><span class="line"></span><br><span class="line">a=a+1;//报错，1为int类型</span><br></pre></td></tr></table></figure><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>强制将一个数据，转换成我们要的数据类型，强制类型转换，<em>有可能会发生精度损失的问题</em></p><p>格式：目标数据类型 变量名=(目标数据类型)(被转换的数据);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">byte a = 1;</span><br><span class="line">byte b = 127;</span><br><span class="line">short c =(short) a+b;//运算时虽然自动转换为int类型，但强制转换为short，且128在short数据类型范围内，此处不会发生精度损失</span><br><span class="line">byte c = (byte)128;//输出-128</span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">byte a=10;</span><br><span class="line">byte b=20;</span><br><span class="line">byte r=a+1;  //报错，int转为byte可能发生精度损失</span><br><span class="line">byte rr=3+4; //不会报错 常量优化机制，多个常量相加时，他会先算出结果，看没有在这个数据类型的范围内，如果在，就不报错,如果不在就会报错</span><br><span class="line">char ch=&apos;爱&apos;;  //char 占两个字节，gbk编码一个汉字占两个字节  ANSI 也是一个汉字占两个字节，UTF8 一个汉字占三个字节的</span><br></pre></td></tr></table></figure><h1 id="字符和字符串参与运算"><a href="#字符和字符串参与运算" class="headerlink" title="字符和字符串参与运算"></a>字符和字符串参与运算</h1><p><strong>ASCII码表中: ‘a’97 ‘A’ 65 ‘0’ 48</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char ch = &apos;a&apos;;</span><br><span class="line">char ch2 = ch+1;//报错，从int转换到char可能会有精度损失</span><br><span class="line">int r = ch+1;//不报错，输出98</span><br></pre></td></tr></table></figure><p><strong>当+号运算两端只要任意一端是一个字符串，那么加号就起连接符的作用，就会将两端的内容拼接起来，形成一个新的字符串</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;Hello World!&quot;+100); //&quot;Hello World!100&quot;</span><br><span class="line">System.out.println(&quot;Hello World!&quot;+100+86);//&quot;Hello World!10086&quot;</span><br><span class="line">System.out.println(&quot;Hello World!&quot;+&quot;10086&quot;);// &quot;Hello World!10086&quot;System.out.println(10086+&quot;Hello World!&quot;);//&quot;10086Hello World!&quot;</span><br><span class="line">System.out.println(100+&quot;Hello World!&quot;+100+86);//100Hello World!10086</span><br><span class="line">System.out.println(100+86+&quot;Hello World!&quot;+100+86); //186HelloWorld!10086</span><br><span class="line">System.out.println(&quot;5+5=&quot;+5+5);//&quot;5+5=55&quot;</span><br><span class="line">System.out.println(5+5+&quot;=5+5&quot;);//&quot;10=5+5&quot;</span><br></pre></td></tr></table></figure><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><ul><li><p>什么是运算符:对常量和变量进行操作的符号称为运算符</p></li><li><p>运算符的分类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">算术运算符</span><br><span class="line">赋值运算符</span><br><span class="line">比较运算符</span><br><span class="line">逻辑运算符</span><br><span class="line">位运算符</span><br><span class="line">三目运算符</span><br></pre></td></tr></table></figure><p>注意事项：</p><pre><code>a:整数相除只能得到整数。如果想得到小数，请使用浮点数b:/获取的是除法操作的商，%获取的是除法操作的余数  %运算结果的符号，取决于参与运算是左边的符号。  </code></pre></li></ul><h1 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h1><ul><li>算数运算符有哪些:+ , - , * , / , % , ++ , –</li></ul><p>/：整数相除只能得到整数，要得到小数需使用服浮点数</p><p>++:自加,对原有的数据进行+1<br>–:自减,对原有的数据进行-1</p><p>++,–运算符单独使用：放在操作数的前面和后面效果一样</p><p>++,–参与运算时使用：放在操作数的前面，先自增或者自减，然后再参与运算</p><p>放在操作数的后面，先参与运算，再自增或者自减</p><p>案例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a = 3;</span><br><span class="line">a++;//此处a=4</span><br><span class="line">++a;//此处a=5</span><br><span class="line">a--;//a=4</span><br><span class="line">--a;//a=3</span><br><span class="line">int num = a++;  //num=3  a=4</span><br><span class="line">int num2 = ++a;  //num2=5  a=5</span><br></pre></td></tr></table></figure><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算符有哪些：=， +=,-=,*=,/=,%=</p><p>案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">byte b =3;</span><br><span class="line">b = b+1;  //报错</span><br><span class="line">b+=1;  //不报错，会自动强制类型转换，然后判断累加完的结果，在不在这个数据类型的范围内，如果不在会自动强制类型转换</span><br></pre></td></tr></table></figure><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>关系运算符有哪些：== ,!= , &lt; , &gt; , &lt;= , &gt;=</p><p>关系运算符运算结果是booean型</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>逻辑运算符有哪些：&amp;(并且) , |(或者) , !(非) , ^(异或) , &amp;&amp;(短路与) , ||(短路或)</p><p>逻辑运算符运算结果是booean型</p><p>&amp;(并且) , |(或者) 和 &amp;&amp;(短路与) ,||(短路或) 在运算结果上没有区别，区别在运算效率上：&amp;，运算符两端都会计算，而&amp;&amp;，||只要左端能得出计算结果，则不会执行右端</p><p>案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int b = 2;</span><br><span class="line">boolean flag = a==2 &amp;&amp; (a&gt;b);//&amp;&amp;左端已经为false，则右端不会再进行判断</span><br><span class="line">System.out.println()</span><br></pre></td></tr></table></figure><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>语法：布尔表达式?结果1:结果2</p><p>案例：求两个数最大值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int b = 2;</span><br><span class="line">int max = a&gt;b?a:b;</span><br></pre></td></tr></table></figure><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符有哪些：</p><p>​        &amp;(与)，|(或)，^(异或) , ~(按位取反) , &lt;&lt;(左移) ,&gt;&gt;(右移) ,&gt;&gt;&gt;(无符号右移)</p><p>&amp;:有0则0<br>|:有1则1<br>^:相同则0，不同则1<br>~:按位取反 0变1 1变0</p><p>&lt;&lt; : 把&lt;&lt;左边的数据乘以2的移动次幂 例如 10&lt;&lt;3 结果 10*2^3=80</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int flag = 1&amp;2;  //0</span><br><span class="line">int flag = 1|2;  //3</span><br><span class="line">int flag = ~3;  //-4</span><br><span class="line">int num = 3&gt;&gt;2;  //3/2^2=0</span><br><span class="line">int num = 3&lt;&lt;2;  //3*2^2=12</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java简介、注释、、常见DOS命令</title>
      <link href="/2019/04/01/Java%E7%AE%80%E4%BB%8B%E3%80%81%E6%B3%A8%E9%87%8A%E3%80%81%E3%80%81%E5%B8%B8%E8%A7%81DOS%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/04/01/Java%E7%AE%80%E4%BB%8B%E3%80%81%E6%B3%A8%E9%87%8A%E3%80%81%E3%80%81%E5%B8%B8%E8%A7%81DOS%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="一、DOS常用命令"><a href="#一、DOS常用命令" class="headerlink" title="一、DOS常用命令"></a>一、DOS常用命令</h1><table><thead><tr><th>DOS命令</th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>cd + 目录名</td><td>进入该目录</td></tr><tr><td>cd…</td><td>回退上一级目录</td></tr><tr><td>cd…/…/</td><td>回退上两级目录</td></tr><tr><td>cd /盘符 + 完整路径名</td><td>跨盘操作</td></tr><tr><td>md + 目录名</td><td>新建一个目录</td></tr><tr><td>rd + 目录名</td><td>删除一个空目录</td></tr><tr><td>rd /s + 目录名</td><td>删除非空目录，删除前会确认是否删除</td></tr><tr><td>rd /s /q + 目录名</td><td>删除非空目录，直接删除</td></tr><tr><td>del + 文件名.后缀名</td><td>删除该文件</td></tr><tr><td>del + *.后缀名</td><td>删除该目录下所有该后缀名的文件</td></tr><tr><td>mspaint</td><td>打开画图</td></tr><tr><td>calc</td><td>打开计算器</td></tr><tr><td>cls</td><td>清屏</td></tr><tr><td>exit</td><td>退出</td></tr><tr><td>hsotname</td><td>查看主机名</td></tr><tr><td>ipconfig</td><td>查看IP地址</td></tr><tr><td>shutdow -s -t 0</td><td>在0秒后关机</td></tr></tbody></table><h1 id="二、JDK-JRE-JVM"><a href="#二、JDK-JRE-JVM" class="headerlink" title="二、JDK JRE JVM"></a>二、JDK JRE JVM</h1><p>JDK：java开发工具包，提供给开发人员编写java程序<br>JRE：java运行环境，源代码由JRE运行<br>JVM：java虚拟机，实现跨平台<br>注：JDK包含JRE，使用JDK开发java程序，交给JRE运行，由JVM实现跨平台</p><h1 id="三、Java的三种注释"><a href="#三、Java的三种注释" class="headerlink" title="三、Java的三种注释"></a>三、Java的三种注释</h1><p>//单行注释</p><p>/<em><br>多行注释</em>/</p><p>/*<em><br>文档注释</em>/</p><h1 id="四、标识符"><a href="#四、标识符" class="headerlink" title="四、标识符"></a>四、标识符</h1><p>给类，变量等起的名字<br>不能以数字开头<br>可使用的符号：_ $<br>见名知意<br>给类命名首字母大写，多个字母采用驼峰式命名，如StudentName</p><h1 id="五、常量"><a href="#五、常量" class="headerlink" title="五、常量"></a>五、常量</h1><p>定义：在程序中值不会发生的量称作常量，分为字面值常量和自定义常量<br>字面值常量：</p><p>整数常量（1 2 3…）<br>小数常量（1.1 …）<br>字符常量（‘a’ ‘A’ ‘1’…）注：单引号括起来的一个字符<br>字符串常量（“String” “1” “A”）注：用双引号括起来的一个或多个字符<br>布尔常量（true false）</p><p>空常量（null）</p><h1 id="六、关键字的概述和使用"><a href="#六、关键字的概述和使用" class="headerlink" title="六、关键字的概述和使用"></a>六、关键字的概述和使用</h1><p>A:什么是关键字<br>    就是被java语言赋予特殊含义的单词。<br>B:关键字的特点<br>    组成关键的字母都是小写<br>C:常见关键字<br>    class,public,static,void …..<br>D:关键字的注意事项<br>    (1): goto和const是java语言的保留字<br>    (2): 类似与editplus这样的高级文本编辑器对关键字都是有颜色变化的</p><h1 id="七、标识符的概述和组成规则"><a href="#七、标识符的概述和组成规则" class="headerlink" title="七、标识符的概述和组成规则"></a>七、标识符的概述和组成规则</h1><p>“见名知意”<br>A:什么是标识符<br>    就是给类,接口,方法,变量,常量等起名字时使用的字符序列<br>B:标识符的组成规则<br>    (1): 英文的大小写字母<br>    (2): 数字字符<br>    (3): $和_<br>C:标识符注意事项<br>    (1): 不能以数字开头<br>    (2): 不能是java中的关键字<br>    (3): 区分大小写</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎访问我的博客！</title>
      <link href="/2019/03/01/hello-world/"/>
      <url>/2019/03/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>技术博客、人生感悟、随便写写。</p><p>大家笑一笑就好！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
